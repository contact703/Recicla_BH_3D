


<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>ReciclaBH 3D - v48 ‚Äî Poste Luz Conectada</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap');

    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      font-family: 'Fredoka', 'Segoe UI', cursive, sans-serif;
      background: #87ceeb;
      user-select: none;
    }

    #gameCanvas {
      position: fixed;
      inset: 0;
      display: block;
      outline: none;
    }

    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 4px; height: 4px;
      margin-left: -2px; margin-top: -2px;
      background-color: #ffffff;
      border-radius: 50%;
      pointer-events: none;
      z-index: 100;
      box-shadow: 0 0 4px 2px rgba(255, 255, 255, 0.8),
                  0 0 8px 4px rgba(0, 0, 0, 0.5);
    }
    
    #crosshair.aiming {
      width: 3px; height: 3px;
      margin-left: -1.5px; margin-top: -1.5px;
      background-color: #ff3333;
      box-shadow: 0 0 6px 3px rgba(255, 50, 50, 1),
                  0 0 15px 6px rgba(255, 0, 0, 0.5);
    }
    
    /* Cruz da mira */
    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background-color: rgba(255, 255, 255, 0.9);
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
    }
    
    #crosshair::before {
      width: 16px; height: 2px;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
    }
    
    #crosshair::after {
      width: 2px; height: 16px;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
    }
    
    #crosshair.aiming::before,
    #crosshair.aiming::after {
      background-color: rgba(255, 100, 100, 0.9);
    }
    
    /* Sniper carregado - mira dourada brilhante */
    #crosshair.sniper-ready {
      background-color: #ffdd00;
      box-shadow: 0 0 10px 5px rgba(255, 221, 0, 1),
                  0 0 25px 10px rgba(255, 200, 0, 0.7),
                  0 0 40px 15px rgba(255, 150, 0, 0.4);
      animation: sniperPulse 0.5s infinite ease-in-out;
    }
    
    #crosshair.sniper-ready::before,
    #crosshair.sniper-ready::after {
      background-color: rgba(255, 221, 0, 1);
      box-shadow: 0 0 8px rgba(255, 200, 0, 0.8);
    }
    
    @keyframes sniperPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.3); }
    }

    /* Barra de carregamento do Sniper */
    #sniper-charge-container {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, 20px);
      width: 60px;
      height: 6px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 3px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      pointer-events: none;
      z-index: 101;
      opacity: 0;
      transition: opacity 0.2s ease;
      overflow: hidden;
    }
    
    #sniper-charge-container.visible {
      opacity: 1;
    }
    
    #sniper-charge-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #ff6600, #ffaa00, #ffdd00);
      border-radius: 2px;
      transition: width 0.05s linear;
      box-shadow: 0 0 8px rgba(255, 170, 0, 0.8);
    }
    
    #sniper-charge-bar.full {
      background: linear-gradient(90deg, #ffdd00, #ffff00);
      box-shadow: 0 0 12px rgba(255, 221, 0, 1),
                  0 0 20px rgba(255, 200, 0, 0.6);
      animation: chargeFullPulse 0.3s infinite ease-in-out;
    }
    
    @keyframes chargeFullPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    #startScreen {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      color: #fff;
      text-align: center;
      z-index: 10;
      pointer-events: auto;
      transition: opacity 0.5s ease;
    }

    #title {
      font-size: 5rem;
      font-weight: 700;
      letter-spacing: 2px;
      margin-bottom: 1rem;
      animation: floatTitle 3s infinite ease-in-out;
    }
    
    .title-recicla {
      color: #2ecc71;
      text-shadow: 
        -2px -2px 0 #1a5c32,
        2px -2px 0 #1a5c32,
        -2px 2px 0 #1a5c32,
        2px 2px 0 #1a5c32,
        3px 3px 0 #145228,
        0 0 20px rgba(46, 204, 113, 0.6);
    }
    
    .title-bh {
      color: #f1c40f;
      text-shadow: 
        -2px -2px 0 #7d6608,
        2px -2px 0 #7d6608,
        -2px 2px 0 #7d6608,
        2px 2px 0 #7d6608,
        3px 3px 0 #5c4b06,
        0 0 20px rgba(241, 196, 15, 0.6);
    }
    
    .title-3d {
      color: #3498db;
      text-shadow: 
        -2px -2px 0 #1a4a6e,
        2px -2px 0 #1a4a6e,
        -2px 2px 0 #1a4a6e,
        2px 2px 0 #1a4a6e,
        3px 3px 0 #123a56,
        0 0 20px rgba(52, 152, 219, 0.6);
    }

    @keyframes floatTitle {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-15px); }
    }

    #subtitle {
      font-size: 1.5rem;
      max-width: 800px;
      background: rgba(255, 255, 255, 0.9);
      color: #023e8a;
      padding: 1.5rem;
      border-radius: 20px;
      border: 4px solid #023e8a;
      box-shadow: 0 6px 0 #00000040;
      line-height: 1.4;
      margin-bottom: 2rem;
    }

    #startHint {
      font-size: 2rem;
      color: #ffeb3b;
      text-shadow: 2px 2px 0 #000;
      animation: blink 1s infinite;
      cursor: pointer;
    }

    @keyframes blink {
      0%, 100% { opacity: 0.2; }
      50% { opacity: 1; }
    }

    #hud {
      position: fixed;
      top: 15px;
      left: 15px;
      right: 15px;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 15px;
      pointer-events: none;
      z-index: 5;
    }

    .hud-panel {
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50px;
      padding: 10px 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border: 2px solid #fff;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      pointer-events: auto;
      transition: transform 0.1s;
      min-width: 100px;
    }

    .panel-life { }
    .panel-score { }
    .panel-mission { flex: 2; align-items: flex-start; border-radius: 25px; }
    .panel-trash { }

    .hud-label {
      font-size: 1rem;
      font-weight: 700;
      text-transform: uppercase;
      margin-bottom: 4px;
      color: #fff;
    }

    .hud-value {
      font-size: 1.8rem;
      font-weight: 800;
      color: #fff;
    }

    #hearts {
      display: flex; gap: 6px;
    }
    .heart {
      width: 28px; height: 28px; 
      position: relative;
      overflow: hidden;
    }
    /* Cora√ß√£o vazio (fundo cinza) */
    .heart::before {
      content: "‚ù§Ô∏è";
      font-size: 26px;
      position: absolute;
      left: 0; top: 0;
      opacity: 0.3;
      filter: grayscale(100%);
    }
    /* Cora√ß√£o cheio (vermelho sobreposto) */
    .heart::after {
      content: "‚ù§Ô∏è";
      font-size: 26px;
      position: absolute;
      left: 0; top: 0;
      opacity: 0;
      filter: none;
    }
    .heart.full::after { opacity: 1; }
    /* Meio cora√ß√£o - mostra s√≥ metade esquerda do vermelho */
    .heart.half::after { 
      opacity: 1; 
      clip-path: inset(0 50% 0 0); /* corta a metade direita */
    }

    /* Barra de Stamina */
    #stamina-container {
      width: 100%;
      height: 20px;
      background: rgba(0,0,0,0.4);
      border-radius: 10px;
      overflow: hidden;
      border: 2px solid rgba(255,255,255,0.3);
    }
    #stamina-bar {
      height: 100%;
      background: linear-gradient(90deg, #00b894, #55efc4);
      border-radius: 8px;
      transition: width 0.1s ease-out;
      box-shadow: 0 0 10px rgba(85, 239, 196, 0.5);
    }
    #stamina-bar.low {
      background: linear-gradient(90deg, #e17055, #fdcb6e);
    }
    #stamina-bar.depleted {
      background: linear-gradient(90deg, #d63031, #e74c3c);
    }

    #missionText {
      font-size: 1.1rem;
      color: #fff;
      font-weight: 600;
      line-height: 1.2;
      text-align: left;
    }

    #currentTrashText {
      font-size: 1.4rem;
      font-weight: 800;
      padding: 4px 12px;
      border-radius: 20px;
      background: rgba(255,255,255,0.2);
      color: #fff;
    }

    /* Notifica√ß√£o Discreta (Topo) */
    #messageBox {
      position: fixed;
      top: 110px; /* Logo abaixo do HUD */
      left: 50%;
      /* Centraliza horizontalmente apenas */
      transform: translateX(-50%) scale(0.9);
      
      background: #fff;
      border: 3px solid #2f3542; /* Borda mais fina */
      border-radius: 12px;       /* Menos arredondado */
      padding: 10px 20px;        /* Padding reduzido */
      text-align: center;
      box-shadow: 0 4px 0 rgba(0,0,0,0.2);
      
      opacity: 0;
      pointer-events: none;
      transition: all 0.2s ease-out;
      z-index: 20;
      max-width: 400px;          /* Largura limitada */
    }
    #messageBox.visible {
      opacity: 1;
      transform: translateX(-50%) scale(1);
      top: 120px; /* Pequena anima√ß√£o de entrada */
    }
    #messageTitle {
      font-size: 1.1rem; /* Fonte do t√≠tulo bem menor */
      font-weight: 800;
      color: #ff4757;
      margin-bottom: 2px;
      text-transform: uppercase;
    }
    #messageBody {
      font-size: 0.9rem; /* Fonte do corpo menor */
      color: #2f3542;
      font-weight: 600;
      line-height: 1.2;
    }

    #controlsHint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      font-size: 1rem;
      padding: 10px 20px;
      border-radius: 50px;
      border: 2px solid #fff;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      display: none;
      z-index: 4;
      white-space: nowrap;
    }

    #ammoHud {
      position: fixed;
      bottom: 75px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      flex-direction: row;
      gap: 12px;
      z-index: 4;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 16px;
      border-radius: 30px;
      border: 2px solid rgba(255,255,255,0.3);
    }
    .ammo-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }
    .ammo-circle {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 3px solid transparent;
    }
    .ammo-item.selected .ammo-circle {
      border-color: #fff;
      box-shadow: 0 0 12px rgba(255,255,255,0.8);
    }
    .ammo-label {
      font-size: 0.7rem;
      color: #fff;
      font-weight: bold;
    }
    .ammo-key {
      font-size: 0.65rem;
      color: #aaa;
      background: #333;
      padding: 1px 5px;
      border-radius: 3px;
    }
    
    .key-icon {
        display: inline-block;
        background: #eee;
        color: #333;
        border-radius: 6px;
        padding: 2px 6px;
        margin: 0 2px;
        font-weight: bold;
        border-bottom: 3px solid #ccc;
        font-size: 0.9em;
    }

    #victoryScreen {
      display: none;
      position: fixed; inset: 0;
      background: rgba(46, 213, 115, 0.95);
      align-items: center; justify-content: center;
      flex-direction: column;
      z-index: 15;
      text-align: center;
    }
    #victoryTitle { font-size: 4rem; color: #fff; text-shadow: 4px 4px 0 #000; margin-bottom: 20px; }
    #victoryText {
      max-width: 600px;
      font-size: 1.3rem;
      margin-bottom: 1.5rem;
      color: #fff;
      line-height: 1.5;
    }
    #victoryBtn {
      font-size: 1.5rem; padding: 15px 40px;
      border-radius: 50px; border: none;
      background: #fff; color: #2ed573;
      font-weight: 800; cursor: pointer;
      box-shadow: 0 6px 0 #1e8e4c;
      transition: transform 0.1s;
    }
    #victoryBtn:active { transform: translateY(4px); box-shadow: 0 2px 0 #1e8e4c; }

    @media (max-width: 700px) {
        #hud { flex-wrap: wrap; }
        .panel-mission { order: 3; width: 100%; min-width: auto; }
        #title { font-size: 3rem; }
    }
    
    /* ========== MENU DE PAUSE ========== */
    #pauseMenu {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(10px);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }
    
    #pauseMenu.active {
      display: flex;
    }
    
    .pause-container {
      background: rgba(0, 0, 0, 0.9);
      border: 3px solid #fff;
      border-radius: 30px;
      padding: 40px 60px;
      min-width: 400px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.5);
    }
    
    .pause-title {
      font-size: 2.5rem;
      font-weight: 800;
      color: #fff;
      text-align: center;
      margin-bottom: 30px;
      text-transform: uppercase;
      letter-spacing: 3px;
    }
    
    .pause-section {
      margin-bottom: 25px;
    }
    
    .pause-label {
      font-size: 1.1rem;
      font-weight: 700;
      color: #fff;
      text-transform: uppercase;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .pause-slider-container {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    
    .pause-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 12px;
      border-radius: 10px;
      background: rgba(255,255,255,0.2);
      outline: none;
      cursor: pointer;
    }
    
    .pause-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #4CAF50;
      cursor: pointer;
      border: 3px solid #fff;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      transition: transform 0.1s;
    }
    
    .pause-slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }
    
    .pause-slider::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #4CAF50;
      cursor: pointer;
      border: 3px solid #fff;
    }
    
    .pause-value {
      font-size: 1.2rem;
      font-weight: 700;
      color: #4CAF50;
      min-width: 50px;
      text-align: right;
    }
    
    .pause-hint {
      text-align: center;
      color: rgba(255,255,255,0.6);
      font-size: 1rem;
      margin-top: 30px;
    }
    
    .pause-hint span {
      background: rgba(255,255,255,0.2);
      padding: 5px 12px;
      border-radius: 8px;
      font-weight: 700;
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.163/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div id="crosshair" style="left:50%; top:50%"></div>
  
  <!-- Barra de carregamento do Sniper -->
  <div id="sniper-charge-container">
    <div id="sniper-charge-bar"></div>
  </div>

  <div id="startScreen">
    <div id="title">
      <span class="title-recicla">Recicla</span><span class="title-bh">BH</span> <span class="title-3d">3D</span>
    </div>
    <div id="subtitle">
      üåç Bem-vindo ao jogo educativo de reciclagem! Sua miss√£o √© coletar os sacos de lixo 
      espalhados pela cidade e coloc√°-los nas lixeiras corretas. Cuidado com os carros 
      e aprenda a reciclar de forma divertida! ‚ôªÔ∏è
    </div>
    <div id="startHint">üéÆ Clique ou pressione Enter para jogar!</div>
  </div>

  <div id="hud" style="display:none;">
    <div class="hud-panel panel-life">
      <div class="hud-label">‚ù§Ô∏è Energia</div>
      <div id="hearts"></div>
    </div>
    
    <div class="hud-panel panel-stamina">
      <div class="hud-label">üèÉ Corrida</div>
      <div id="stamina-container">
        <div id="stamina-bar" style="width: 100%;"></div>
      </div>
    </div>
    
    <div class="hud-panel panel-score">
      <div class="hud-label">‚≠ê Pontos</div>
      <div class="hud-value" id="scoreText">0</div>
    </div>
    
    <div class="hud-panel panel-mission">
      <div class="hud-label">üìã Miss√£o Atual</div>
      <div id="missionText">Recicle 10 sacos corretamente!</div>
    </div>
    
    <div class="hud-panel panel-trash">
      <div class="hud-label">‚úã Segurando</div>
      <div id="currentTrashText">Nada</div>
    </div>
  </div>

  <div id="ammoHud">
    <div class="ammo-item selected" data-type="Metal">
      <div class="ammo-circle" style="background-color: #ffd93b;"></div>
      <span class="ammo-label">Metal</span>
      <span class="ammo-key">1</span>
    </div>
    <div class="ammo-item" data-type="Vidro">
      <div class="ammo-circle" style="background-color: #27e36a;"></div>
      <span class="ammo-label">Vidro</span>
      <span class="ammo-key">2</span>
    </div>
    <div class="ammo-item" data-type="Pl√°stico">
      <div class="ammo-circle" style="background-color: #ff3b3b;"></div>
      <span class="ammo-label">Pl√°stico</span>
      <span class="ammo-key">3</span>
    </div>
    <div class="ammo-item" data-type="Papel">
      <div class="ammo-circle" style="background-color: #1e90ff;"></div>
      <span class="ammo-label">Papel</span>
      <span class="ammo-key">4</span>
    </div>
  </div>

  <div id="controlsHint">
    <span class="key-icon">W</span><span class="key-icon">A</span><span class="key-icon">S</span><span class="key-icon">D</span> Mover &nbsp;‚Ä¢&nbsp; 
    <span class="key-icon">Mouse</span> Mirar &nbsp;‚Ä¢&nbsp; 
    <span class="key-icon">Clique</span> Atirar &nbsp;‚Ä¢&nbsp; 
    <span class="key-icon">Direito</span> Zoom &nbsp;‚Ä¢&nbsp; 
    <span class="key-icon">E</span> Pegar &nbsp;‚Ä¢&nbsp; 
    <span class="key-icon">Shift</span> Correr
  </div>
  
  <!-- MENU DE PAUSE -->
  <div id="pauseMenu">
    <div class="pause-container">
      <div class="pause-title">‚è∏Ô∏è Pausado</div>
      
      <div class="pause-section">
        <div class="pause-label">üîä Volume do Jogo</div>
        <div class="pause-slider-container">
          <input type="range" class="pause-slider" id="volumeSlider" min="0" max="100" value="50">
          <span class="pause-value" id="volumeValue">50%</span>
        </div>
      </div>
      
      <div class="pause-section">
        <div class="pause-label">üéØ Sensibilidade da Mira</div>
        <div class="pause-slider-container">
          <input type="range" class="pause-slider" id="sensitivitySlider" min="10" max="200" value="100">
          <span class="pause-value" id="sensitivityValue">100%</span>
        </div>
      </div>
      
      <div class="pause-hint">Pressione <span>ESC</span> para continuar</div>
    </div>
  </div>

  <div id="messageBox">
    <div id="messageTitle"></div>
    <div id="messageBody"></div>
  </div>

  <div id="victoryScreen">
    <div id="victoryTitle">Parab√©ns!</div>
    <div id="victoryText">
      Voc√™ domou os monstrinhos do lixo, protegeu sua vida e reciclou corretamente a pra√ßa.
      Continue explorando, ensinando e inspirando novas formas de cuidar da cidade.
    </div>
    <button id="victoryBtn">Jogar novamente</button>
  </div>

  <script type="module">
    import * as THREE from "three";

    // ReciclaBH 3D - v15 ‚Äî Pegar Lixo com a M√£o Livre
    //
    // Polaris Patch ‚Äî City V2 + Vertical Look + Bite Combat
    // - Vertical camera pitch with mouse drag.
    // - Monsters upgraded to low-poly bodies with legs/mouth animation.
    // - Close-range "bite" combat mode with glow + windup + cooldown.

    // ==========================
    // CONFIG
    // ==========================

    const KEY_CODES = {
      W: "KeyW",
      A: "KeyA",
      S: "KeyS",
      D: "KeyD",
      E: "KeyE",
      Q: "KeyQ",
      SHIFT: "ShiftLeft",
      ENTER: "Enter",
      SPACE: "Space"
    };

    const BIN_DEFINITIONS = [
      { name: "Azul",     material: "Papel",    color: 0x1e90ff },
      { name: "Vermelho", material: "Pl√°stico", color: 0xff3b3b },
      { name: "Verde",    material: "Vidro",    color: 0x27e36a },
      { name: "Amarelo",  material: "Metal",    color: 0xffd93b }
    ];

    const MONSTER_CONFIG = {
      "Papel":    { color: 0x1e90ff, speed: 2.0 },
      "Pl√°stico": { color: 0xff3b3b, speed: 2.2 },
      "Vidro":    { color: 0x27e36a, speed: 2.0 },
      "Metal":    { color: 0xffd93b, speed: 1.8 }
    };

    const TARGET_CORRECT = 10;
    const SHOOT_COOLDOWN = 0.18;
    const PROJECTILE_SPEED = 150;
    const PROJECTILE_LIFETIME = 1.2;
    const MONSTER_SPAWN_MIN = 12;
    const MONSTER_SPAWN_MAX = 16;
    const MONSTER_SPAWN_INTERVAL = 45;
    const MONSTER_MAX = 24;

    const MAX_HEARTS = 5;
    const DAMAGE_BY_TYPE = { Papel: 0.5, Pl√°stico: 1.0, Vidro: 1.5, Metal: 2.0 };
    const TOUCH_COOLDOWN = 0.6;

    const BAG_PICK_DURATION = 0.25;
    const BAG_CARRY_BOB_AMPL = 0.02;
    const BAG_CARRY_BOB_FREQ = 6.0;

    const SELF_COLLISION_RADIUS_PLAYER = 0.46;
    const SELF_COLLISION_RADIUS_BAG = 0.33;
    const SELF_COLLISION_STRENGTH = 0.45;

    // --- Self-collision constants (Arm/Torso & Foot planting) ---
    const TORSO_RADIUS = 0.34;
    const ARM_CLEARANCE = 0.04;
    const SOLE_HEIGHT = 0.06;
    const FOOT_PLANT_STRENGTH = 0.35;

    // --- CITY GRID CONFIG (strict) ---
    const ROAD_W = 7.0; // Aumentado de 4 para 7
    const SIDEWALK_W = 1.5;
    const BLOCK_SIZE = 16;
    const GRID_RADIUS = 2;
    const BUILDING_SIZE = 6;
    const BUILDING_SPACING = 2;
    const PARK_W = 12;
    const PARK_H = 8;

    // --- BITE COMBAT CONFIG ---
    const BITE_RANGE        = 4.5;   // distance to enter combat mode
    const BITE_HOLD_RANGE   = 6.0;   // distance to keep chasing once engaged
    const BITE_SPEED_MULT   = 2.0;   // speed while in bite chase
    const BITE_WINDUP_TIME  = 0.35;  // attack windup before the bite
    const BITE_COOLDOWN     = 1.2;   // delay between bites

    // ==========================
    // GLOBAL STATE
    // ==========================

    let renderer, scene, camera, clock;
    let player, cameraPivot;
    let keys = {};
    let mouseDown = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let cameraPitch = 0; // in radians, positive looks up
    let cameraYaw = 0; // C√¢mera controla a dire√ß√£o de mira
    let isAiming = false; // Bot√£o direito para mirar (mais zoom)
    let aimStartTime = 0; // Quando come√ßou a mirar
    let sniperReady = false; // Se o tiro sniper est√° carregado
    const SNIPER_CHARGE_TIME = 2.0; // Segundos para carregar o sniper
    let gameStarted = false;
    let gameCompleted = false;
    let isGameOver = false;
    let isPaused = false; // Menu de pause
    
    // Configura√ß√µes do jogador
    let gameVolume = 0.5; // 0 a 1
    let mouseSensitivity = 1.0; // Multiplicador de sensibilidade

    let currentScore = 0;
    let correctCount = 0;

    // Sistema de Muni√ß√£o
    let currentWeapon = "Metal";
    const WEAPON_DATA = {
      "Metal":    { color: 0xffd93b, key: "1" },
      "Vidro":    { color: 0x27e36a, key: "2" },
      "Pl√°stico": { color: 0xff3b3b, key: "3" },
      "Papel":    { color: 0x1e90ff, key: "4" }
    };

    let monsters = [];
    let projectiles = [];
    let bins = [];
    let occupiedSpots = [];
    let cars = [];
    let clouds = [];

    let currentHeldBag = null;
    let currentHeldBagMesh = null;
    let currentHeldBagCarryOffset = 0;
    let isPickingBag = false;

    let timeSinceLastSpawn = 0;
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üöÄ OTIMIZA√á√ÉO: Vetores tempor√°rios reutiliz√°veis (evita GC)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const _tempVec3_1 = new THREE.Vector3();
    const _tempVec3_2 = new THREE.Vector3();
    const _tempVec3_3 = new THREE.Vector3();
    const _tempVec3_4 = new THREE.Vector3();
    
    // Cache de elementos DOM (evita getElementById repetido)
    let _cachedStaminaBar = null;
    let _cachedSniperContainer = null;
    let _cachedSniperBar = null;
    let _domCacheInitialized = false;
    
    function initDOMCache() {
      if (_domCacheInitialized) return;
      _cachedStaminaBar = document.getElementById("stamina-bar");
      _cachedSniperContainer = document.getElementById("sniper-charge-container");
      _cachedSniperBar = document.getElementById("sniper-charge-bar");
      _domCacheInitialized = true;
    }

    const startScreen = document.getElementById("startScreen");
    const hudEl = document.getElementById("hud");
    const scoreText = document.getElementById("scoreText");
    const missionTextEl = document.getElementById("missionText");
    const currentTrashText = document.getElementById("currentTrashText");
    const messageBox = document.getElementById("messageBox");
    const messageTitleEl = document.getElementById("messageTitle");
    const messageBodyEl = document.getElementById("messageBody");
    const controlsHint = document.getElementById("controlsHint");
    const victoryScreen = document.getElementById("victoryScreen");
    const victoryBtn = document.getElementById("victoryBtn");
    const crosshair = document.getElementById("crosshair");
    const heartsEl = document.getElementById("hearts");

    let messageTimeout = null;
    let lastShotTime = -999;
    let carHitCooldown = 0; // Cooldown para evitar m√∫ltiplos danos por atropelamento

    let audioContext = null;
    let masterGain = null;
    let globalTime = 0;
    let playerHearts = MAX_HEARTS;

    // Sistema de Stamina (corrida)
    const MAX_STAMINA = 100;
    const STAMINA_DRAIN_RATE = 25; // Gasta por segundo correndo
    const STAMINA_REGEN_RATE = 15; // Recupera por segundo parado
    const STAMINA_REGEN_DELAY = 0.5; // Segundos antes de come√ßar a recuperar
    let playerStamina = MAX_STAMINA;
    let staminaRegenTimer = 0;
    let canSprint = true;
    let playerIsSprinting = false; // Estado global de corrida para anima√ß√£o

    // Rig / anima√ß√£o
    let rigTime = 0;
    let blinkTimer = 0;
    let nextBlinkIn = 2.0;

    // Two-hand shooting pose timer
    let shootPoseTimer = 0;

    // Raycasting / mira
    let raycaster = null;
    let mouseNDC = null;
    let aimPlane = null;
    let aimPoint = null;

    let gunBaseLocalPos = null;

    // Backpack animation helpers
    let backpackBouncePhase = 0;

    // ---- COLIS√ÉO EST√ÅTICA ----
    window.staticColliders = window.staticColliders || [];
    const staticColliders = window.staticColliders;

    function addBoxCollider(cx, cz, hx, hz, yTop = 100) {
      staticColliders.push({ type: "box", cx, cz, hx, hz, yTop });
    }

    function addCylCollider(cx, cz, r, yTop = 100) {
      staticColliders.push({ type: "cyl", cx, cz, r, yTop });
    }

    // Nova fun√ß√£o para detectar o ch√£o em (x,z)
    function getGroundHeight(x, z) {
      let maxY = 0; // Ch√£o padr√£o
      
      for (const c of staticColliders) {
        // Se for parede infinita (yTop=100), n√£o conta como ch√£o caminh√°vel
        if (c.yTop > 10) continue; 

        let inside = false;
        if (c.type === "box") {
          if (Math.abs(x - c.cx) < c.hx && Math.abs(z - c.cz) < c.hz) inside = true;
        } else {
          const d2 = (x - c.cx)**2 + (z - c.cz)**2;
          if (d2 < c.r * c.r) inside = true;
        }
        
        if (inside && c.yTop > maxY) {
          maxY = c.yTop;
        }
      }
      return maxY;
    }

function resolveCapsuleVsColliders(pos, radius) {
  const feetY = pos.y + 0.2; // Sobe um pouco para n√£o trope√ßar em cal√ßada baixa

  for (const c of staticColliders) {
    // Se o objeto √© baixo (cal√ßada), ignora se o p√© estiver acima
    if (feetY >= c.yTop) continue;

    if (c.type === "box") {
      // Calcula ponto mais pr√≥ximo na borda da caixa
      const closestX = Math.max(c.cx - c.hx, Math.min(pos.x, c.cx + c.hx));
      const closestZ = Math.max(c.cz - c.hz, Math.min(pos.z, c.cz + c.hz));
      
      const dx = pos.x - closestX;
      const dz = pos.z - closestZ;
      const distSq = dx*dx + dz*dz;
      
      if (distSq < radius * radius && distSq > 0) {
         const dist = Math.sqrt(distSq);
         const overlap = radius - dist;
         const nx = dx / dist;
         const nz = dz / dist;
         
         pos.x += nx * overlap;
         pos.z += nz * overlap;
      } else if (distSq === 0) {
        // Jogador est√° DENTRO da caixa - empurra para a borda mais pr√≥xima
        const distToLeft = pos.x - (c.cx - c.hx);
        const distToRight = (c.cx + c.hx) - pos.x;
        const distToBack = pos.z - (c.cz - c.hz);
        const distToFront = (c.cz + c.hz) - pos.z;
        
        const minDist = Math.min(distToLeft, distToRight, distToBack, distToFront);
        
        if (minDist === distToLeft) {
          pos.x = c.cx - c.hx - radius;
        } else if (minDist === distToRight) {
          pos.x = c.cx + c.hx + radius;
        } else if (minDist === distToBack) {
          pos.z = c.cz - c.hz - radius;
        } else {
          pos.z = c.cz + c.hz + radius;
        }
      }
    } else if (c.type === "cyl") {
      const dx = pos.x - c.cx;
      const dz = pos.z - c.cz;
      const distSq = dx*dx + dz*dz;
      const minDist = c.r + radius;
      
      if (distSq < minDist * minDist) {
         const dist = Math.sqrt(distSq) || 0.001;
         const overlap = minDist - dist;
         const nx = dx / dist;
         const nz = dz / dist;
         
         pos.x += nx * overlap;
         pos.z += nz * overlap;
      }
    }
  }
}

    // 2. Reconstrutor de Colis√£o (Prioridade para Mesa)
    function rebuildStaticColliders() {
      staticColliders.length = 0; // Limpa colis√µes antigas

      // Limites do Mapa
      const halfSpan = GRID_RADIUS * BLOCK_SIZE + ROAD_W + SIDEWALK_W + 4;
      addBoxCollider(0,  halfSpan + 0.5, halfSpan, 0.5);
      addBoxCollider(0, -halfSpan - 0.5, halfSpan, 0.5);
      addBoxCollider( halfSpan + 0.5, 0, 0.5, halfSpan);
      addBoxCollider(-halfSpan - 0.5, 0, 0.5, halfSpan);

      // Colis√£o das Lixeiras - altura real da lixeira (1.2) para poder pular por cima
      bins.forEach(b => {
        addCylCollider(b.mesh.position.x, b.mesh.position.z, 0.5, 1.2);
      });

      const worldPos = new THREE.Vector3();

      scene.traverse(obj => {
        if (!obj.name) return;
        const name = obj.name.toLowerCase();
        
        // Pega posi√ß√£o global do objeto
        obj.getWorldPosition(worldPos);

        // --- PR√âDIOS E CASAS (Corre√ß√£o considerando rota√ß√£o) ---
        if (name === "building_collider" && obj.geometry && obj.geometry.parameters) {
           // Pega o tamanho exato da geometria
           const w = obj.geometry.parameters.width;
           const d = obj.geometry.parameters.depth;
           
           let hx = w / 2 + 0.1; // Pequeno padding
           let hz = d / 2 + 0.1;
           
           // Verifica rota√ß√£o do objeto pai (casa pode estar rotacionada)
           if (obj.parent && obj.parent.rotation) {
             const rotY = obj.parent.rotation.y;
             // Normaliza rota√ß√£o para 0 a 2œÄ
             const normalizedRot = ((rotY % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
             
             // Se rota√ß√£o ~90¬∞ (œÄ/2) ou ~270¬∞ (3œÄ/2), inverte width e depth
             const isRotated90 = (normalizedRot > Math.PI * 0.25 && normalizedRot < Math.PI * 0.75) ||
                                 (normalizedRot > Math.PI * 1.25 && normalizedRot < Math.PI * 1.75);
             if (isRotated90) {
               hx = d / 2 + 0.1;
               hz = w / 2 + 0.1;
             }
           }
           
           addBoxCollider(worldPos.x, worldPos.z, hx, hz);
           return;
        }

        // --- OUTROS OBJETOS ---
        
        // Cal√ßadas (com colis√£o para subir o degrau)
        if (name === "sidewalk_collider" && obj.children.length > 0) {
           // Assume que o primeiro filho √© o mesh da cal√ßada
           const mesh = obj.children[0];
           if (mesh.geometry && mesh.geometry.parameters) {
               const w = mesh.geometry.parameters.width;
               const d = mesh.geometry.parameters.depth;
               addBoxCollider(worldPos.x, worldPos.z, w/2, d/2, 0.06);
           }
           return;
        }

        // Mesa de Xadrez
        if (name.includes("chess_table_collider")) {
           addCylCollider(worldPos.x, worldPos.z, 0.9, 0.75);
           return;
        }

        // Objetos Cil√≠ndricos Gerais
        if (name.includes("bench_collider")) addCylCollider(worldPos.x, worldPos.z, 1.2, 0.6);
        if (name.includes("bush_collider"))  addCylCollider(worldPos.x, worldPos.z, 0.6, 0.6);
        if (name.includes("hydrant_collider")) addCylCollider(worldPos.x, worldPos.z, 0.45, 0.8);
        
        // Postes e Troncos
        if (name.includes("post") || name.includes("tree_trunk")) {
            addCylCollider(worldPos.x, worldPos.z, 0.4, 100);
        }
      });
    }

    // Ground detection helpers
    let groundRay = null;
    let groundTargets = [];

    // ==========================
    // AUDIO
    // ==========================

    function initAudio() {
      if (audioContext) return;
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        masterGain.gain.value = 0.15;
        masterGain.connect(audioContext.destination);
      } catch {
        audioContext = null;
      }
    }

    function playTone({ freq = 600, duration = 0.08, type = "square", volume = 1, decay = 0.003 } = {}) {
      if (!audioContext || !masterGain) return;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.type = type;
      osc.frequency.value = freq;

      gain.gain.value = volume;
      gain.gain.exponentialRampToValueAtTime(
        Math.max(0.001, volume * 0.25),
        audioContext.currentTime + Math.max(decay, duration * 0.5)
      );

      osc.connect(gain);
      gain.connect(masterGain);

      osc.start();
      osc.stop(audioContext.currentTime + duration);
    }

    const playShootSound = () =>
      playTone({ freq: 880, duration: 0.06, type: "square", volume: 0.8, decay: 0.02 });
    const playSniperSound = () => {
      // Som mais grave e poderoso para o tiro sniper
      playTone({ freq: 180, duration: 0.25, type: "sawtooth", volume: 1.0, decay: 0.1 });
      playTone({ freq: 350, duration: 0.15, type: "square", volume: 0.7, decay: 0.05 });
    };
    const playHitSound = () =>
      playTone({ freq: 520, duration: 0.07, type: "square", volume: 0.9, decay: 0.03 });
    const playTransformSound = () =>
      playTone({ freq: 420, duration: 0.13, type: "triangle", volume: 0.9, decay: 0.05 });
    const playCorrectSound = () =>
      playTone({ freq: 720, duration: 0.12, type: "triangle", volume: 0.9, decay: 0.05 });
    const playWrongSound = () =>
      playTone({ freq: 260, duration: 0.14, type: "sawtooth", volume: 0.7, decay: 0.08 });

    // ==========================
    // RENDERER & SCENE
    // ==========================

    function initRenderer() {
      const canvas = document.getElementById("gameCanvas");
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1.5, 2));
      renderer.outputEncoding = THREE.sRGBEncoding;
    }

    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      clock = new THREE.Clock();

      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        500
      );

      cameraPivot = new THREE.Object3D();
      scene.add(cameraPivot);

      raycaster = new THREE.Raycaster();
      mouseNDC = new THREE.Vector2();
      aimPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      aimPoint = new THREE.Vector3();

      const ambient = new THREE.AmbientLight(0xe0f7ff, 0.72);
      scene.add(ambient);

      const dir = new THREE.DirectionalLight(0xffffff, 0.95);
      dir.position.set(25, 50, 15);
      scene.add(dir);

      createGroundAndDecor();
      createPlayer();
      createBins();
      
      // Inicializa contadores de casas e pr√©dios
      window.houseCount = 0;
      window.buildingCount = 0;
      window.buildingSlots = 0;
      
      createCityV2();
      createTunnels();
      createLandscape(); // Anel de montanhas ao redor da cidade
      createCloudSystem();
      spawnTraffic();

      // Initialize ground targets for foot planting
      groundRay = new THREE.Raycaster();
      groundTargets = [];
      scene.traverse(obj => {
        if (!(obj instanceof THREE.Mesh)) return;
        const n = (obj.name || "").toLowerCase();
        if (n === "ground" || n === "plaza" || n === "sidewalk" || n.includes("road")) {
          groundTargets.push(obj);
        }
      });

      updateHUD();
      playerHearts = MAX_HEARTS;
      renderHearts();
    }

    // ==========================
    // ENVIRONMENT
    // ==========================

    function createGroundAndDecor() {
      const size = GRID_RADIUS * BLOCK_SIZE * 3;
      const groundGeo = new THREE.PlaneGeometry(size, size, 1, 1);
      const groundMat = new THREE.MeshLambertMaterial({ color: 0x3f8f3a });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      ground.name = "ground";
      scene.add(ground);

      // Central lamps removed - replaced with global street lighting system

      // Central lamp post area - hydrants removed, keeping only the lamp
    }

    // 1. √Årvore Realista (Tronco c√¥nico + Copa volumosa "Nuvem")
    function createTree(px, pz) {
      const group = new THREE.Group();
      
      // Tronco (C√¥nico e mais escuro)
      const trunkGeo = new THREE.CylinderGeometry(0.15, 0.25, 1.4, 7);
      const trunkMat = new THREE.MeshLambertMaterial({ color: 0x5d4037 });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.name = "tree_trunk"; // Para colis√£o
      trunk.position.y = 0.7;
      group.add(trunk);

      // Copa (Cluster de esferas para dar volume)
      const leavesMat = new THREE.MeshLambertMaterial({ color: 0x2e7d32 });
      const positions = [
        { x: 0, y: 1.6, z: 0, s: 0.9 },
        { x: 0.4, y: 1.4, z: 0.4, s: 0.7 },
        { x: -0.4, y: 1.5, z: -0.3, s: 0.75 },
        { x: 0.3, y: 1.3, z: -0.4, s: 0.65 },
        { x: -0.3, y: 1.4, z: 0.3, s: 0.7 }
      ];

      positions.forEach(p => {
        const leaf = new THREE.Mesh(new THREE.SphereGeometry(p.s, 7, 7), leavesMat);
        leaf.position.set(p.x, p.y, p.z);
        group.add(leaf);
      });

      group.position.set(px, 0, pz);
      group.rotation.y = Math.random() * Math.PI; // Rota√ß√£o aleat√≥ria
      scene.add(group);
    }

    function createLampPost(x, z, rotationY = 0) {
      const group = new THREE.Group();
      group.name = "lamp_post_collider"; // Colis√£o

      // Materiais
      const matConcrete = new THREE.MeshLambertMaterial({ color: 0x999999 });
      const matMetal    = new THREE.MeshLambertMaterial({ color: 0x2c3e50 }); // Cinza azulado escuro
      const matLight    = new THREE.MeshBasicMaterial({ color: 0xffffaa });   // L√¢mpada

      // 1. Base de Concreto
      const base = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.45, 0.4, 16), matConcrete);
      base.position.y = 0.2;
      group.add(base);

      // 2. Haste Principal (Alta)
      const height = 5.5;
      const poleGeo = new THREE.CylinderGeometry(0.12, 0.18, height, 8);
      const pole = new THREE.Mesh(poleGeo, matMetal);
      pole.position.y = 0.4 + height / 2;
      group.add(pole);

      // 3. Bra√ßo (Curva para a rua)
      const armLen = 2.0;
      const armGeo = new THREE.BoxGeometry(0.12, 0.12, armLen);
      const arm = new THREE.Mesh(armGeo, matMetal);
      // Posiciona no topo e avan√ßa para frente (Z positivo)
      arm.position.set(0, 0.4 + height - 0.2, armLen / 2 - 0.1); 
      // Leve inclina√ß√£o para cima
      arm.rotation.x = -Math.PI / 12; 
      group.add(arm);

      // 4. Cabe√ßa da L√¢mpada (Cobra Head) - como filho do bra√ßo para conectar perfeitamente
      const headGeo = new THREE.BoxGeometry(0.25, 0.15, 0.5);
      const head = new THREE.Mesh(headGeo, matMetal);
      // Na ponta do bra√ßo (z = armLen/2 porque √© relativo ao centro do bra√ßo)
      head.position.set(0, 0, armLen / 2 + 0.1);
      arm.add(head);

      // 5. A L√¢mpada (Emissive)
      const bulb = new THREE.Mesh(new THREE.PlaneGeometry(0.2, 0.4), matLight);
      bulb.rotation.x = Math.PI / 2; // Virada para baixo
      bulb.position.set(0, -0.08, 0); // Embaixo da cabe√ßa
      head.add(bulb);

      // 6. Luz Real (SpotLight)
      // A luz sai da cabe√ßa da l√¢mpada
      const spotLight = new THREE.SpotLight(0xffffaa, 3, 14, 0.8, 0.5, 1);
      spotLight.position.set(0, -0.1, 0);
      head.add(spotLight);
      
      // O alvo da luz √© o ch√£o, um pouco √† frente do poste
      const targetObj = new THREE.Object3D();
      targetObj.position.set(0, 0, armLen + 2);
      group.add(targetObj);
      spotLight.target = targetObj;

      // Posicionamento Global
      group.position.set(x, 0, z);
      group.rotation.y = rotationY;
      scene.add(group);
      
      // Colis√£o F√≠sica (Poste)
      addCylCollider(x, z, 0.35);
    }

    // Create fire hydrant
    // Create fire hydrant (vers√£o corrigida ‚Äì mesh limpo e sem artefatos)
    function createHydrant(x, z) {
      const group = new THREE.Group();
      group.name = "hydrant_collider";

      // Materiais
      const redMat      = new THREE.MeshLambertMaterial({ color: 0xd32f2f });
      const greyMat     = new THREE.MeshLambertMaterial({ color: 0x888888 });
      const concreteMat = new THREE.MeshLambertMaterial({ color: 0x777777 });

      // 0. BASE DE CONCRETO ‚Äì levemente acima do ch√£o para evitar z-fighting
      const concreteGeo = new THREE.CylinderGeometry(0.38, 0.38, 0.06, 20);
      const concrete    = new THREE.Mesh(concreteGeo, concreteMat);
      concrete.position.y = 0.03;
      concrete.receiveShadow = true;
      group.add(concrete);

      // 1. BASE VERMELHA
      const baseGeo = new THREE.CylinderGeometry(0.26, 0.30, 0.16, 20);
      const base    = new THREE.Mesh(baseGeo, redMat);
      base.position.y = 0.16;
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);

      // 2. CORPO PRINCIPAL
      const bodyGeo = new THREE.CylinderGeometry(0.20, 0.20, 0.80, 20);
      const body    = new THREE.Mesh(bodyGeo, redMat);
      body.position.y = 0.60;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);

      // 3. TOPO ARREDONDADO
      const topGeo = new THREE.SphereGeometry(0.21, 18, 12, 0, Math.PI * 2, 0, Math.PI / 2);
      const top    = new THREE.Mesh(topGeo, redMat);
      top.position.y = 1.02;
      top.castShadow = true;
      top.receiveShadow = true;
      group.add(top);

      // 4. PORCA SUPERIOR
      const nutGeo = new THREE.CylinderGeometry(0.075, 0.075, 0.08, 6);
      const nut    = new THREE.Mesh(nutGeo, greyMat);
      nut.position.y = 1.20;
      nut.castShadow = true;
      nut.receiveShadow = true;
      group.add(nut);

      // 5. BRA√áO LATERAL
      const armGeo = new THREE.CylinderGeometry(0.11, 0.11, 0.60, 16);
      const arm    = new THREE.Mesh(armGeo, redMat);
      arm.rotation.z = Math.PI / 2;
      arm.position.y = 0.80;
      arm.castShadow = true;
      arm.receiveShadow = true;
      group.add(arm);

      // 6. TAMPAS LATERAIS
      const capGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.06, 20);

      const capL = new THREE.Mesh(capGeo, greyMat);
      capL.rotation.z = Math.PI / 2;
      capL.position.set(-0.33, 0.80, 0);
      capL.castShadow = true;
      capL.receiveShadow = true;
      group.add(capL);

      const capR = capL.clone();
      capR.position.x = 0.33;
      group.add(capR);

      // POSICIONAMENTO FINAL
      group.position.set(x, 0, z);
      group.rotation.y = Math.random() * Math.PI;

      scene.add(group);
    }



    // ==========================
    // CITY GENERATION - REALISTIC GRID LAYOUT
    // ==========================

    function clearOldCity() {
      const toRemove = [];
      scene.traverse(o => {
        if (!o.isMesh && !o.isGroup) return;
        const n = (o.name || "").toLowerCase();
        if (
          n.includes("road") || n.includes("sidewalk") || n.includes("building") ||
          n.includes("park") || n.includes("fence") || n.includes("bench") ||
          n.includes("trashcan") || n.includes("planter") || n.includes("zebra") ||
          n.includes("garden") || n.includes("flower") || n.includes("bush") ||
          n.includes("lamp") || n.includes("tree") || n.includes("hydrant") ||
          n.includes("stop") || n.includes("sign") || n.includes("intersection") ||
          n.includes("curb") || n.includes("grass") ||
          o.userData && o.userData.isStreetLamp
        ) {
          toRemove.push(o);
        }
      });
      toRemove.forEach(o => {
        scene.remove(o);
        // Dispose geometry and material to free memory
        if (o.geometry) o.geometry.dispose();
        if (o.material) {
          if (Array.isArray(o.material)) {
            o.material.forEach(m => m.dispose());
          } else {
            o.material.dispose();
          }
        }
      });
    }

    // Helper: create ground plane
    function makePlane(w, h, color) {
      const g = new THREE.PlaneGeometry(w, h);
      const m = new THREE.MeshLambertMaterial({ color });
      const p = new THREE.Mesh(g, m);
      p.rotation.x = -Math.PI / 2;
      p.receiveShadow = true;
      return p;
    }

    // Create straight roads with sidewalks and curbs
    // 1. Rua Limpa (Apenas Asfalto e Faixa Amarela)
    // 1. Segmento de Rua (Conecta dois cruzamentos)
    function createRoadSegment(x, z, isHorizontal) {
      const len = BLOCK_SIZE; // 16.0
      const w = ROAD_W; // 7.0
      
      // Asfalto
      const roadGeo = new THREE.PlaneGeometry(isHorizontal ? len : w, isHorizontal ? w : len);
      const roadMat = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
      const road = new THREE.Mesh(roadGeo, roadMat);
      road.rotation.x = -Math.PI/2;
      road.position.set(x, 0.005, z);
      road.name = "road_segment";
      scene.add(road);

      // Faixa Branca Tracejada
      const dashLen = 1.5;
      const dashGap = 1.5;
      // Deixa margem nas pontas para n√£o encostar no cruzamento
      const usableLen = len - 2.0; 
      const numDashes = Math.floor(usableLen / (dashLen + dashGap));
      
      const dashGeo = new THREE.PlaneGeometry(isHorizontal ? dashLen : 0.15, isHorizontal ? 0.15 : dashLen);
      const dashMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      
      const startPos = (isHorizontal ? x : z) - ((numDashes-1)*(dashLen+dashGap))/2;

      for(let i=0; i<numDashes; i++) {
        const dash = new THREE.Mesh(dashGeo, dashMat);
        const p = startPos + i * (dashLen + dashGap);
        
        dash.rotation.x = -Math.PI/2;
        if(isHorizontal) dash.position.set(p, 0.01, z);
        else dash.position.set(x, 0.01, p);
        scene.add(dash);
      }
    }

    // 2. Cruzamento (Quadrado de Asfalto Puro)
    function createIntersection(x, z) {
      const w = ROAD_W;
      const inter = new THREE.Mesh(
        new THREE.PlaneGeometry(w, w),
        new THREE.MeshLambertMaterial({ color: 0x2a2a2a }) // Mesmo material da rua
      );
      inter.rotation.x = -Math.PI/2;
      inter.position.set(x, 0.005, z);
      inter.name = "intersection";
      scene.add(inter);
    }

    // 2. Cal√ßadas do Quarteir√£o (Cria o anel de concreto em volta do bloco)
    // Gera textura de tijolinhos (Paver) via c√≥digo
    function createPaverTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 256;
      const ctx = canvas.getContext('2d');
      
      // Fundo (Rejunte escuro)
      ctx.fillStyle = '#999999'; 
      ctx.fillRect(0, 0, 256, 256);
      
      // Tijolos (Cinza claro)
      ctx.fillStyle = '#cccccc';
      const brickW = 60; const brickH = 30; const gap = 4;
      
      for(let y=0; y<256+brickH; y+=brickH+gap) {
          const offset = (Math.floor(y/(brickH+gap)) % 2 === 0) ? 0 : brickW/2;
          for(let x=-brickW; x<256+brickW; x+=brickW+gap) {
              ctx.fillRect(x + offset, y, brickW, brickH);
          }
      }
      
      const tex = new THREE.CanvasTexture(canvas);
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.RepeatWrapping;
      // Ajusta repeti√ß√£o para ficar na escala certa no ch√£o
      tex.repeat.set(2, 10); 
      return tex;
    }

    // Textura global para n√£o recriar toda hora
    const paverTexture = createPaverTexture();

    // 1. Cal√ßadas com Textura Paver (Tijolinhos Intertravados)
    function createBlockSidewalks(cx, cz) {
      if (Math.abs(cx) < 1.0 && Math.abs(cz) < 1.0) return;

      const swWidth = 1.5; 
      const swHeight = 0.05; 
      const totalSize = BLOCK_SIZE - ROAD_W; 
      const offset = totalSize / 2 + swWidth / 2; 

      // Material Paver
      const matPaver = new THREE.MeshLambertMaterial({ map: paverTexture });
      const matCurb = new THREE.MeshLambertMaterial({ color: 0x888888 });

      const mkSw = (px, pz, w, d, isHorizontal) => {
        const group = new THREE.Group();
        
        // 1. Cal√ßada (Com textura de Paver)
        // Ajusta a repeti√ß√£o da textura baseado no tamanho
        const localTex = paverTexture.clone();
        localTex.needsUpdate = true;
        localTex.repeat.set(w / 1.5, d / 1.5); // Escala aproximada 1.5m por repeti√ß√£o
        
        const m = new THREE.Mesh(new THREE.BoxGeometry(w, swHeight, d), new THREE.MeshLambertMaterial({ map: localTex }));
        group.add(m);
        
        // 2. Meio-Fio (Curb)
        const curbSize = 0.15;
        const curb = new THREE.Mesh(new THREE.BoxGeometry(
            isHorizontal ? w : curbSize, 
            swHeight + 0.02, 
            isHorizontal ? curbSize : d
        ), matCurb);
        
        // Posiciona meio-fio na borda externa
        // L√≥gica simplificada: se est√° longe do centro (cx,cz), empurra pra fora?
        // Vamos colocar meio-fio nas bordas que tocam a rua.
        // ... (Para simplificar visualmente, o meio fio √© uma borda cinza escura ao redor)
        
        group.position.set(px, swHeight/2, pz);
        group.name = "sidewalk_collider";
        scene.add(group);
        
        // Colis√£o √∫nica
        addBoxCollider(px, pz, w/2, d/2, 0.06);
      };

      const longLen = totalSize + (swWidth * 2); 
      const shortLen = totalSize; 

      mkSw(cx, cz - offset, longLen, swWidth, true); 
      mkSw(cx, cz + offset, longLen, swWidth, true); 
      mkSw(cx - offset, cz, swWidth, shortLen, false); 
      mkSw(cx + offset, cz, swWidth, shortLen, false); 
    }

    // 3. Placa de PARE (Oct√≥gono Vermelho)
    // 2. Placa de PARE (Oct√≥gono Vermelho) - Rota√ß√£o Corrigida
    function createStopSign(x, z, rotationY) {
      const group = new THREE.Group();
      
      // Poste Cinza Met√°lico
      const pole = new THREE.Mesh(
        new THREE.CylinderGeometry(0.04, 0.04, 2.2, 8),
        new THREE.MeshLambertMaterial({ color: 0x555555 })
      );
      pole.position.y = 1.1;
      group.add(pole);

      // Placa Octogonal
      const signGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.04, 8); 
      const signMat = new THREE.MeshLambertMaterial({ color: 0xcc0000 }); // Vermelho vivo
      const sign = new THREE.Mesh(signGeo, signMat);
      sign.rotation.x = Math.PI / 2;
      sign.rotation.y = Math.PI / 8; // Alinha faces do oct√≥gono
      sign.position.set(0, 2, 0.03); // Encostado no poste
      group.add(sign);

      // Texto "PARE" (Faixa Branca)
      const strip = new THREE.Mesh(
        new THREE.BoxGeometry(0.5, 0.12, 0.05),
        new THREE.MeshBasicMaterial({ color: 0xffffff })
      );
      strip.position.set(0, 2, 0.04); // Na frente da placa
      group.add(strip);

      // Posiciona na esquina
      group.position.set(x, 0, z);
      group.rotation.y = rotationY; // Rota√ß√£o passada pelo gerador
      scene.add(group);
      addCylCollider(x, z, 0.1);
    }

    // 4. Quebra-Molas (Speed Bump)
    // 3. Quebra-Molas (Lombada Amarela Padr√£o)
    function createSpeedBump(x, z, isHorizontal) {
      // Largura total da via (7.0m) x 0.8m de comprimento
      const bumpLen = isHorizontal ? 0.8 : ROAD_W;
      const bumpWid = isHorizontal ? ROAD_W : 0.8;
      
      // Geometria suave (Cilindro cortado ao meio)
      const bumpGeo = new THREE.CylinderGeometry(0.3, 0.3, isHorizontal ? ROAD_W : ROAD_W, 16, 1, false, 0, Math.PI);
      const bumpMat = new THREE.MeshLambertMaterial({ color: 0xffcc00 }); // Amarelo BHTrans

      const bump = new THREE.Mesh(bumpGeo, bumpMat);
      
      if (isHorizontal) {
         bump.rotation.z = Math.PI / 2;
      } else {
         bump.rotation.x = Math.PI / 2;
         bump.rotation.z = Math.PI / 2;
      }
      
      bump.scale.set(1, 0.25, 1); // Achata a altura (0.3 * 0.25 = ~7.5cm de altura)
      bump.position.set(x, 0, z);
      scene.add(bump);
    }

    // Create zebra crossing
    function createZebraCrossing(x, z, isHorizontal) {
      const stripes = 5;
      const stripeWidth = 0.5;
      const gap = 0.4;
      
      for (let i = 0; i < stripes; i++) {
        const w = isHorizontal ? stripeWidth : ROAD_W - 0.4;
        const h = isHorizontal ? ROAD_W - 0.4 : stripeWidth;
        const offset = (i - (stripes - 1) / 2) * (stripeWidth + gap);
        
        const stripe = makePlane(w, h, 0xffffff);
        if (isHorizontal) {
          stripe.position.set(x + offset, 0.010, z);
        } else {
          stripe.position.set(x, 0.010, z + offset);
        }
        stripe.name = "zebra";
        scene.add(stripe);
      }
    }

    // Create building on a block
    // Create buildings with windows and roof - VERS√ÉO SIMPLIFICADA: Janelas filhas do pr√©dio
function createBuilding(cx, cz, height, color) {
  const width = BUILDING_SIZE; // 6
  const depth = BUILDING_SIZE; // 6

  const group = new THREE.Group();
  group.name = "building_wrapper";

  // Materiais
  const matWall  = new THREE.MeshLambertMaterial({ color: color });
  const matFrame = new THREE.MeshLambertMaterial({ color: 0x222222 }); // Preto
  const matDoor  = new THREE.MeshLambertMaterial({ color: 0x5d4037 }); // Madeira
  const matGlass = new THREE.MeshLambertMaterial({ color: 0xadd8e6 }); // Vidro
  const matRoof  = new THREE.MeshLambertMaterial({ color: 0x333333 }); // Telhado
  const matMetal = new THREE.MeshLambertMaterial({ color: 0x555555 }); // Metal

  // 1. CORPO DO PR√âDIO
  const body = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), matWall);
  body.position.y = height / 2;
  body.castShadow = true;
  body.receiveShadow = true;
  body.name = "building_collider"; 
  group.add(body);

  // Colis√£o ser√° adicionada automaticamente pelo rebuildStaticColliders

  // 2. PORTA (NO CH√ÉO AGORA)
  const doorGroup = new THREE.Group();
  
  // Frame e Folha
  const frameH = 2.6;
  const frame = new THREE.Mesh(new THREE.BoxGeometry(1.6, frameH, 0.2), matFrame);
  doorGroup.add(frame);
  
  const leaf = new THREE.Mesh(new THREE.BoxGeometry(1.3, 2.3, 0.1), matDoor);
  leaf.position.z = 0.1; // Pra fora do frame
  leaf.position.y = -0.15; // Ajuste vertical dentro do frame
  doorGroup.add(leaf);

  const knob = new THREE.Mesh(new THREE.SphereGeometry(0.08), new THREE.MeshLambertMaterial({color: 0xffd700}));
  knob.position.set(0.5, -0.1, 0.18); 
  doorGroup.add(knob);

  const awning = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.1, 0.8), matMetal);
  awning.position.set(0, frameH/2 + 0.1, 0.4);
  doorGroup.add(awning);

  // --- L√ìGICA DE POSICIONAMENTO CORRIGIDA ---
  const distW = width / 2;
  const distD = depth / 2;
  // O centro do body √© (0,0). O ch√£o √© -height/2.
  // A porta tem altura frameH. O centro da porta deve ser: (-height/2) + (frameH/2).
  const doorY = (-height / 2) + (frameH / 2);

  const toCenter = new THREE.Vector3(-cx, 0, -cz);
  if (Math.abs(toCenter.x) > Math.abs(toCenter.z)) {
    if (cx > 0) { // Direita -> Porta na Esquerda (-X)
        doorGroup.position.set(-distW, doorY, 0);
        doorGroup.rotation.y = -Math.PI / 2;
    } else { // Esquerda -> Porta na Direita (+X)
        doorGroup.position.set(distW, doorY, 0);
        doorGroup.rotation.y = Math.PI / 2;
    }
  } else {
    if (cz > 0) { // Baixo -> Porta em Cima (-Z)
        doorGroup.position.set(0, doorY, -distD);
        doorGroup.rotation.y = Math.PI;
    } else { // Cima -> Porta em Baixo (+Z)
        doorGroup.position.set(0, doorY, distD);
        doorGroup.rotation.y = 0;
    }
  }
  
  body.add(doorGroup);

  // 3. JANELAS (Grid System - Sem colis√£o com a porta)
  const winW = 1.2, winH = 1.4, winD = 0.2;
  const winGeo = new THREE.BoxGeometry(winW, winH, winD);
  
  function addWindow(bx, by, bz, isRotated) {
      const win = new THREE.Mesh(winGeo, matGlass);
      const border = new THREE.Mesh(new THREE.BoxGeometry(winW+0.2, winH+0.2, winD-0.05), matFrame);
      win.add(border);
      
      win.position.set(bx, by, bz);
      if (isRotated) win.rotation.y = Math.PI / 2;
      body.add(win);
  }

  // Loop come√ßa em 4.5 metros do ch√£o
  // Como y dentro do loop √© "altura do ch√£o", precisamos converter para local.
  // Local Y = y - (height/2)
  for (let y = 4.5; y < height - 1.5; y += 3.0) {
      const localY = y - (height/2);
      
      for (let x = -width/2 + 1.5; x < width/2; x += 2.5) {
          addWindow(x, localY, depth/2, false);  // Frente
          addWindow(x, localY, -depth/2, false); // Tr√°s
      }
      for (let z = -depth/2 + 1.5; z < depth/2; z += 2.5) {
          addWindow(width/2, localY, z, true);   // Direita
          addWindow(-width/2, localY, z, true);  // Esquerda
      }
  }

  // 4. TELHADO
  const roof = new THREE.Mesh(new THREE.BoxGeometry(width + 0.4, 0.5, depth + 0.4), matRoof);
  roof.position.y = height / 2 + 0.25;
  body.add(roof);

  // Props do Telhado (Antena, etc)
  if (Math.random() > 0.5) {
      const ant = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2), matMetal);
      ant.position.y = 1.0;
      roof.add(ant);
  }

  group.position.set(cx, 0, cz);
  scene.add(group);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üè† CASA RESIDENCIAL - Estilo suburbano com telhado inclinado
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function createHouse(cx, cz, wallColor) {
  const group = new THREE.Group();
  group.name = "house_wrapper";
  
  // Dimens√µes da casa
  const width = 5.5;    // Largura
  const depth = 4.5;    // Profundidade
  const wallHeight = 3.2; // Altura das paredes
  const roofHeight = 2.0; // Altura do telhado
  
  // Materiais - USANDO A COR PASSADA PARA AS PAREDES!
  const matWall = new THREE.MeshLambertMaterial({ color: wallColor }); // Cor da reciclagem
  const matRoof = new THREE.MeshLambertMaterial({ color: 0x4a5568 }); // Cinza azulado
  const matTrim = new THREE.MeshLambertMaterial({ color: 0xf5deb3 }); // Bege/trigo
  const matWood = new THREE.MeshLambertMaterial({ color: 0xdeb887 }); // Madeira clara
  const matGlass = new THREE.MeshLambertMaterial({ color: 0x87ceeb }); // Vidro azul claro
  const matFrame = new THREE.MeshLambertMaterial({ color: 0xf0e68c }); // Moldura amarela
  const matDoor = new THREE.MeshLambertMaterial({ color: 0xdaa520 }); // Porta dourada
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // 1. CORPO PRINCIPAL DA CASA - COR DA RECICLAGEM!
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  const bodyGeo = new THREE.BoxGeometry(width, wallHeight, depth);
  const body = new THREE.Mesh(bodyGeo, matWall);
  body.position.y = wallHeight / 2;
  body.castShadow = true;
  body.receiveShadow = true;
  body.name = "building_collider";
  group.add(body);
  
  // Colis√£o ser√° adicionada automaticamente pelo rebuildStaticColliders
  // baseado na posi√ß√£o mundial e rota√ß√£o do mesh
  
  // Rodap√©/Base decorativa (ligeiramente maior para evitar z-fighting)
  const baseGeo = new THREE.BoxGeometry(width + 0.25, 0.35, depth + 0.25);
  const base = new THREE.Mesh(baseGeo, matTrim);
  base.position.y = 0.18;
  group.add(base);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // 2. EMPENAS (paredes triangulares laterais)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  const gableShape = new THREE.Shape();
  gableShape.moveTo(-width/2, 0);
  gableShape.lineTo(0, roofHeight);
  gableShape.lineTo(width/2, 0);
  gableShape.lineTo(-width/2, 0);
  
  const gableGeo = new THREE.ShapeGeometry(gableShape);
  
  // Empena frontal
  const gableFront = new THREE.Mesh(gableGeo, matWall);
  gableFront.position.set(0, wallHeight, depth/2);
  group.add(gableFront);
  
  // Empena traseira
  const gableBack = new THREE.Mesh(gableGeo, matWall);
  gableBack.position.set(0, wallHeight, -depth/2);
  gableBack.rotation.y = Math.PI;
  group.add(gableBack);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // 3. TELHADO (duas √°guas - duas placas inclinadas)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  const roofSlope = Math.atan2(roofHeight, width/2); // √Çngulo de inclina√ß√£o
  const roofLength = Math.sqrt(roofHeight * roofHeight + (width/2) * (width/2)); // Comprimento da √°gua
  
  const roofGeo = new THREE.BoxGeometry(roofLength + 0.1, 0.15, depth + 0.4);
  
  // √Ågua esquerda
  const roofLeft = new THREE.Mesh(roofGeo, matRoof);
  roofLeft.position.set(-width/4 - 0.05, wallHeight + roofHeight/2 + 0.05, 0);
  roofLeft.rotation.z = roofSlope;
  roofLeft.castShadow = true;
  group.add(roofLeft);
  
  // √Ågua direita
  const roofRight = new THREE.Mesh(roofGeo, matRoof);
  roofRight.position.set(width/4 + 0.05, wallHeight + roofHeight/2 + 0.05, 0);
  roofRight.rotation.z = -roofSlope;
  roofRight.castShadow = true;
  group.add(roofRight);
  
  // Cumeeira (topo do telhado)
  const ridgeGeo = new THREE.BoxGeometry(0.2, 0.2, depth + 0.5);
  const ridge = new THREE.Mesh(ridgeGeo, matRoof);
  ridge.position.set(0, wallHeight + roofHeight + 0.05, 0);
  group.add(ridge);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // 4. JANELAS COM MOLDURAS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  function createWindow(w, h) {
    const winGroup = new THREE.Group();
    
    // Moldura externa
    const frameOuter = new THREE.Mesh(
      new THREE.BoxGeometry(w + 0.15, h + 0.15, 0.08),
      matFrame
    );
    winGroup.add(frameOuter);
    
    // Vidro
    const glass = new THREE.Mesh(
      new THREE.BoxGeometry(w, h, 0.05),
      matGlass
    );
    glass.position.z = 0.02;
    winGroup.add(glass);
    
    // Divis√≥rias da janela (cruz)
    const divV = new THREE.Mesh(
      new THREE.BoxGeometry(0.05, h, 0.06),
      matFrame
    );
    divV.position.z = 0.04;
    winGroup.add(divV);
    
    const divH = new THREE.Mesh(
      new THREE.BoxGeometry(w, 0.05, 0.06),
      matFrame
    );
    divH.position.z = 0.04;
    winGroup.add(divH);
    
    return winGroup;
  }
  
  // Janelas da frente
  const winFront1 = createWindow(0.9, 1.1);
  winFront1.position.set(-1.3, wallHeight * 0.55, depth/2 + 0.05);
  group.add(winFront1);
  
  const winFront2 = createWindow(0.9, 1.1);
  winFront2.position.set(1.3, wallHeight * 0.55, depth/2 + 0.05);
  group.add(winFront2);
  
  // Janelas laterais - LADO DIREITO
  const winSide1 = createWindow(0.8, 1.0);
  winSide1.rotation.y = Math.PI / 2;
  winSide1.position.set(width/2 + 0.05, wallHeight * 0.55, -0.8);
  group.add(winSide1);
  
  const winSide2 = createWindow(0.8, 1.0);
  winSide2.rotation.y = Math.PI / 2;
  winSide2.position.set(width/2 + 0.05, wallHeight * 0.55, 0.8);
  group.add(winSide2);
  
  // Janelas laterais - LADO ESQUERDO
  const winSide3 = createWindow(0.8, 1.0);
  winSide3.rotation.y = -Math.PI / 2;
  winSide3.position.set(-width/2 - 0.05, wallHeight * 0.55, -0.8);
  group.add(winSide3);
  
  const winSide4 = createWindow(0.8, 1.0);
  winSide4.rotation.y = -Math.PI / 2;
  winSide4.position.set(-width/2 - 0.05, wallHeight * 0.55, 0.8);
  group.add(winSide4);
  
  // Janelas de tr√°s
  const winBack1 = createWindow(0.7, 0.9);
  winBack1.rotation.y = Math.PI;
  winBack1.position.set(-1.0, wallHeight * 0.6, -depth/2 - 0.05);
  group.add(winBack1);
  
  const winBack2 = createWindow(0.7, 0.9);
  winBack2.rotation.y = Math.PI;
  winBack2.position.set(1.0, wallHeight * 0.6, -depth/2 - 0.05);
  group.add(winBack2);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // 5. PORTA (sem varanda)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  // Porta
  const doorGroup = new THREE.Group();
  doorGroup.position.set(0, 1.0, depth/2 + 0.06); // Z aumentado para evitar z-fighting
  
  const doorFrame = new THREE.Mesh(
    new THREE.BoxGeometry(1.0, 2.0, 0.12),
    matFrame
  );
  doorGroup.add(doorFrame);
  
  const doorLeaf = new THREE.Mesh(
    new THREE.BoxGeometry(0.85, 1.85, 0.08),
    matDoor
  );
  doorLeaf.position.z = 0.04;
  doorGroup.add(doorLeaf);
  
  // Pain√©is da porta
  const panelGeo = new THREE.BoxGeometry(0.3, 0.6, 0.02);
  const panel1 = new THREE.Mesh(panelGeo, matWood);
  panel1.position.set(0, 0.35, 0.09);
  doorGroup.add(panel1);
  const panel2 = new THREE.Mesh(panelGeo, matWood);
  panel2.position.set(0, -0.35, 0.09);
  doorGroup.add(panel2);
  
  // Ma√ßaneta
  const knob = new THREE.Mesh(
    new THREE.SphereGeometry(0.05, 8, 6),
    new THREE.MeshLambertMaterial({ color: 0xffd700 })
  );
  knob.position.set(0.3, 0, 0.1);
  doorGroup.add(knob);
  
  // Janela da porta
  const doorWindow = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.4, 0.03),
    matGlass
  );
  doorWindow.position.set(0, 0.6, 0.09);
  doorGroup.add(doorWindow);
  
  group.add(doorGroup);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // 6. DETALHES DECORATIVOS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  // Faixa decorativa nas paredes (frente e tr√°s) - offset maior para evitar z-fighting
  const trimGeo = new THREE.BoxGeometry(width + 0.15, 0.1, 0.1);
  const trimFront = new THREE.Mesh(trimGeo, matTrim);
  trimFront.position.set(0, wallHeight - 0.1, depth/2 + 0.06);
  group.add(trimFront);
  
  const trimBack = new THREE.Mesh(trimGeo, matTrim);
  trimBack.position.set(0, wallHeight - 0.1, -depth/2 - 0.06);
  group.add(trimBack);
  
  // Faixa lateral esquerda
  const trimSideGeo = new THREE.BoxGeometry(0.1, 0.1, depth + 0.15);
  const trimLeft = new THREE.Mesh(trimSideGeo, matTrim);
  trimLeft.position.set(-width/2 - 0.06, wallHeight - 0.1, 0);
  group.add(trimLeft);
  
  // Faixa lateral direita
  const trimRight = new THREE.Mesh(trimSideGeo, matTrim);
  trimRight.position.set(width/2 + 0.06, wallHeight - 0.1, 0);
  group.add(trimRight);
  
  // Rotacionar casa para porta ficar voltada para a rua (centro do mapa)
  const toCenter = new THREE.Vector2(-cx, -cz);
  let rotation = 0;
  if (Math.abs(toCenter.x) > Math.abs(toCenter.y)) {
    rotation = toCenter.x > 0 ? -Math.PI / 2 : Math.PI / 2;
  } else {
    rotation = toCenter.y > 0 ? 0 : Math.PI;
  }
  group.rotation.y = rotation;
  
  group.position.set(cx, 0, cz);
  scene.add(group);
}
    function createGarden(cx, cz) {
      const gardenSize = BUILDING_SIZE + 2;
      
      // Garden lawn (gramado central)
      const lawn = makePlane(gardenSize, gardenSize, 0x3f8f3a);
      lawn.position.set(cx, 0.006, cz);
      lawn.name = "garden_lawn";
      scene.add(lawn);
      
      // --- CERCA VIVA COM ABERTURAS E FLORES REALISTAS ---
      const bushGeo = new THREE.IcosahedronGeometry(0.5, 1); 
      const bushMat = new THREE.MeshLambertMaterial({ color: 0x228b22, flatShading: true });
      const flowerColors = [0xff69b4, 0x87ceeb, 0xffffff, 0xffa500]; // Rosa, Azul, Branco, Laranja

  // Fun√ß√£o da Flor (Geometria Maior)
  // Fun√ß√£o da Flor (Geometria Simples - Performance)
  function createDetailedBushFlower(color) {
    const fGroup = new THREE.Group();
    
    // P√©talas (Base - CircleGeometry simples)
    const petalGeo = new THREE.CircleGeometry(0.09, 7);
    const petalMat = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
    const petals = new THREE.Mesh(petalGeo, petalMat);
    fGroup.add(petals);

    // Miolo Amarelo (Topo - Afastado para evitar Z-fighting)
    const center = new THREE.Mesh(
      new THREE.IcosahedronGeometry(0.04, 0), 
      new THREE.MeshLambertMaterial({ color: 0xffff00 })
    );
    center.position.z = 0.03; // Garante que fique na frente das p√©talas
    fGroup.add(center);
    
    return fGroup;
  }

  // Fun√ß√£o do Arbusto com Flores "Filhas"
  function createFloweringBush(bx, bz) {
    const group = new THREE.Group();
    group.name = "bush_collider"; // <--- ETIQUETA

    const bush = new THREE.Mesh(bushGeo, bushMat);
    
    const s = 0.85 + Math.random() * 0.35; 
    bush.scale.set(s, s * 0.75, s); 
    bush.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
    group.add(bush);

    // Flores
    if (Math.random() > 0.3) {
      const color = flowerColors[Math.floor(Math.random() * flowerColors.length)];
      const numFlowers = 6 + Math.floor(Math.random() * 6);
      for(let i=0; i<numFlowers; i++) {
        const flower = createDetailedBushFlower(color);
        const u = Math.random(); const v = Math.random();
        const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
        const r = 0.48; 
        const fx = r * Math.sin(phi) * Math.cos(theta);
        const fy = r * Math.sin(phi) * Math.sin(theta);
        const fz = r * Math.cos(phi);
        flower.position.set(fx, fy, fz);
        flower.lookAt(fx * 2, fy * 2, fz * 2);
        flower.translateZ(0.02);
        bush.add(flower);
      }
    }

    group.position.set(bx, 0.3, bz);
    scene.add(group);
  }

      // Fun√ß√£o de preenchimento com ABERTURAS
      function fillSide(x1, z1, x2, z2) {
        const dist = Math.hypot(x2 - x1, z2 - z1);
        const step = 0.75; 
        const count = Math.floor(dist / step);
        
        for(let i=0; i<=count; i++) {
          const t = i/count;
          
          // *** L√ìGICA DE ABERTURA LARGA ***
          // Se estiver entre 30% e 70% do caminho, pula (deixa vazio)
          if (t > 0.3 && t < 0.7) continue;

          createFloweringBush(x1 + (x2-x1)*t, z1 + (z2-z1)*t);
        }
      }

      const half = (BUILDING_SIZE + 2) / 2;
      // Desenha os lados
      fillSide(cx - half, cz - half, cx + half, cz - half); // Norte
      fillSide(cx + half, cz - half, cx + half, cz + half); // Leste
      fillSide(cx + half, cz + half, cx - half, cz + half); // Sul
      fillSide(cx - half, cz + half, cx - half, cz - half); // Oeste
      
      // --- NOVA FUN√á√ÉO DE BANCO REALISTA ---
      function createDetailedBench(bx, bz) {
        const group = new THREE.Group();
        group.name = "bench_collider"; // <--- ETIQUETA IMPORTANTE

        const woodMat = new THREE.MeshLambertMaterial({ color: 0x8d6e63 });
        const ironMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });

        const legGeo = new THREE.BoxGeometry(0.1, 0.4, 0.5);
        const legL = new THREE.Mesh(legGeo, ironMat); legL.position.set(-0.8, 0.2, 0); group.add(legL);
        const legR = legL.clone(); legR.position.set(0.8, 0.2, 0); group.add(legR);

        const slatGeo = new THREE.BoxGeometry(1.8, 0.05, 0.12);
        for(let i=0; i<3; i++) {
          const slat = new THREE.Mesh(slatGeo, woodMat);
          slat.position.set(0, 0.42, -0.15 + (i * 0.14)); group.add(slat);
        }

        const backSupportGeo = new THREE.BoxGeometry(0.1, 0.5, 0.05);
        const suppL = new THREE.Mesh(backSupportGeo, ironMat); suppL.position.set(-0.8, 0.6, -0.22); suppL.rotation.x = -0.2; group.add(suppL);
        const suppR = suppL.clone(); suppR.position.set(0.8, 0.6, -0.22); suppR.rotation.x = -0.2; group.add(suppR);

        for(let i=0; i<2; i++) {
          const slat = new THREE.Mesh(slatGeo, woodMat);
          slat.position.set(0, 0.65 + (i * 0.15), -0.25 - (i*0.03)); slat.rotation.x = -0.2; group.add(slat);
        }

        group.position.set(bx, 0, bz);
        group.lookAt(cx, 0, cz); 
        scene.add(group);
        
        // Salva como obst√°culo para √°rvores n√£o nascerem em cima
        benchPositions.push({ x: bx, z: bz });
      }

      // --- POSICIONAMENTO DOS 4 BANCOS ---
      const benchPositions = []; // Array para guardar posi√ß√µes e evitar √°rvores
      const dist = 1.6; // Bem mais perto da mesa

      // Cria 4 bancos ao redor do centro (Norte, Sul, Leste, Oeste)
      createDetailedBench(cx, cz - dist); // Norte
      createDetailedBench(cx, cz + dist); // Sul
      createDetailedBench(cx - dist, cz); // Oeste
      createDetailedBench(cx + dist, cz); // Leste
      
      // Central chess/checkers table with detailed design - CORRIGIDO: Z-fighting +0.01
      // 3. Mesa de Xadrez de Concreto com Pe√ßas
      function createGameTable(tx, tz) {
        const group = new THREE.Group();
        group.name = "chess_table_collider"; // <--- TAG PARA F√çSICA

        const concreteMat = new THREE.MeshLambertMaterial({ color: 0x9e9e9e }); 
        const darkMat = new THREE.MeshLambertMaterial({ color: 0x212121 }); 

        // Base robusta
        const base = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.3, 0.6, 32), darkMat);
        base.position.y = 0.3; 
        group.add(base);

        // Tampo de Pedra
        const top = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 0.1, 32), concreteMat);
        top.position.y = 0.65; 
        group.add(top);

        // Tabuleiro (Gerado via Canvas para n√£o precisar de textura externa)
        const boardSize = 0.9;
        const boardGeo = new THREE.PlaneGeometry(boardSize, boardSize);
        
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        const sq = 128/8;
        for(let i=0; i<8; i++) {
          for(let j=0; j<8; j++) {
            ctx.fillStyle = (i+j)%2===0 ? '#dddddd' : '#444444';
            ctx.fillRect(i*sq, j*sq, sq, sq);
          }
        }
        const texture = new THREE.CanvasTexture(canvas);
        texture.magFilter = THREE.NearestFilter; 
        
        const board = new THREE.Mesh(boardGeo, new THREE.MeshBasicMaterial({ map: texture }));
        board.rotation.x = -Math.PI/2; 
        board.position.y = 0.71; // Levemente acima do tampo para n√£o piscar
        group.add(board);

        // Pe√ßas de Xadrez (Low Poly)
        const whitePieceMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
        const blackPieceMat = new THREE.MeshLambertMaterial({ color: 0x111111 });

        function addPiece(bx, bz, isWhite, type) {
          const step = boardSize / 8;
          const x = (bx - 3.5) * step;
          const z = (bz - 3.5) * step;
          
          let geo;
          // 0=Pe√£o, 1=Rei
          if(type === 0) geo = new THREE.CylinderGeometry(0.025, 0.035, 0.10, 8);
          else geo = new THREE.CylinderGeometry(0.02, 0.03, 0.18, 8);

          const p = new THREE.Mesh(geo, isWhite ? whitePieceMat : blackPieceMat);
          p.position.set(x, 0.76, z); // Em cima do tabuleiro
          group.add(p);
        }

        // Coloca algumas pe√ßas simulando um jogo
        addPiece(3, 3, true, 1); // Rei Branco
        addPiece(4, 4, false, 1); // Rei Preto
        addPiece(2, 2, true, 0);  // Pe√£o
        addPiece(5, 2, false, 0); // Pe√£o
        addPiece(1, 6, true, 0);  // Pe√£o

        group.position.set(tx, 0, tz);
        scene.add(group);
      }
      
      // Place central game table
      createGameTable(cx, cz);
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üå∏ FLORES SIMPLES E PERFORM√ÅTICAS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function createFlower(fx, fz, colorHex) {
        const group = new THREE.Group();
        const scale = 0.8 + Math.random() * 0.4;

        // Caule (levemente curvado usando rota√ß√£o de segmentos ou simples inclina√ß√£o)
        const stemGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.35, 4);
        const stemMat = new THREE.MeshLambertMaterial({ color: 0x33691e });
        const stem = new THREE.Mesh(stemGeo, stemMat);
        stem.position.y = 0.175;
        // Inclina√ß√£o aleat√≥ria para parecer org√¢nico
        stem.rotation.z = (Math.random() - 0.5) * 0.3;
        stem.rotation.x = (Math.random() - 0.5) * 0.3;
        group.add(stem);

        // Topo da flor (segue a ponta do caule)
        const topGroup = new THREE.Group();
        topGroup.position.set(0, 0.35, 0); // Topo do caule
        topGroup.rotation.copy(stem.rotation); // Segue a inclina√ß√£o
        group.add(topGroup);

        // MIOLO BRANCO
        const centerGeo = new THREE.SphereGeometry(0.05, 6, 6);
        const centerMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
        const center = new THREE.Mesh(centerGeo, centerMat);
        topGroup.add(center);

        // P√©talas (6 elipsoides ao redor)
        const petalGeo = new THREE.SphereGeometry(0.05, 5, 5);
        const petalMat = new THREE.MeshLambertMaterial({ color: colorHex });
        
        for(let i=0; i<6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          const petal = new THREE.Mesh(petalGeo, petalMat);
          // Afasta do centro
          petal.position.set(Math.cos(angle)*0.06, 0, Math.sin(angle)*0.06);
          // Achata para parecer p√©tala
          petal.scale.set(1, 0.2, 1.5); 
          // Rotaciona para fora
          petal.lookAt(0, 0, 0);
          topGroup.add(petal);
        }

        group.position.set(fx, 0, fz);
        group.scale.setScalar(scale);
        group.rotation.y = Math.random() * Math.PI;
        scene.add(group);
      }
      
      // Array para guardar flores (para anima√ß√£o)
      const flowers = [];
      
      // NOVA FUN√á√ÉO: Scatter flowers randomly - substitui createFlowerBed
      function scatterFlowers(count) {
        const flowerColors = [
          0xff6b9d, 0xff6b6b, 0xdda0dd, // Rosa/vermelho
          0x4ecdc4, 0x45b7d1, 0x96ceb4, // Azul/verde
          0xffeaa7, 0xffcc00 // Amarelo
        ];
        
        let placed = 0;
        let attempts = 0;
        const maxAttempts = count * 20; // Muitas tentativas para garantir coloca√ß√£o
        
        // Lista de flores j√° colocadas para evitar sobreposi√ß√£o
        const placedFlowers = [];
        const minFlowerDistance = 0.5; // Dist√¢ncia m√≠nima entre flores
        
        while (placed < count && attempts < maxAttempts) {
          attempts++;
          
          // Posi√ß√£o aleat√≥ria dentro da √°rea da grama - margem pequena
          const margin = 0.8;
          const fx = cx + (Math.random() - 0.5) * (gardenSize - margin * 2);
          const fz = cz + (Math.random() - 0.5) * (gardenSize - margin * 2);
          
          // Verificar se n√£o est√° perto da mesa central (raio menor)
          const distanceToTable = Math.sqrt(Math.pow(fx - cx, 2) + Math.pow(fz - cz, 2));
          if (distanceToTable < 1.3) continue;
          
          // Verificar se n√£o est√° perto dos bancos (dist√¢ncia menor)
          let tooCloseToBench = false;
          for (const bench of benchPositions) {
            const distanceToBench = Math.sqrt(Math.pow(fx - bench.x, 2) + Math.pow(fz - bench.z, 2));
            if (distanceToBench < 0.9) {
              tooCloseToBench = true;
              break;
            }
          }
          if (tooCloseToBench) continue;
          
          // Verificar se n√£o est√° muito perto de outras flores
          let tooCloseToFlower = false;
          for (const flower of placedFlowers) {
            const distToFlower = Math.sqrt(Math.pow(fx - flower.x, 2) + Math.pow(fz - flower.z, 2));
            if (distToFlower < minFlowerDistance) {
              tooCloseToFlower = true;
              break;
            }
          }
          if (tooCloseToFlower) continue;
          
          // Flor √© v√°lida - criar com cor aleat√≥ria
          const color = flowerColors[Math.floor(Math.random() * flowerColors.length)];
          createFlower(fx, fz, color);
          
          placedFlowers.push({ x: fx, z: fz });
          placed++;
        }
        
        // N√£o exibir warning - flores s√£o decorativas e o jardim fica bonito
        // mesmo se n√£o conseguir colocar todas
      }
      
      // Scatter random flowers throughout the garden
      scatterFlowers(25); // 25 flores distribu√≠das aleatoriamente
      
      // Helper function to check if a position is too close to existing benches
      function isNearBench(px, pz, minDistance = 1.2) {
        for (const bench of benchPositions) {
          const distance = Math.sqrt(Math.pow(px - bench.x, 2) + Math.pow(pz - bench.z, 2));
          if (distance < minDistance) {
            return true;
          }
        }
        return false;
      }
      
      // Safe tree creation function that avoids benches
      // √Årvore Realista - VERS√ÉO SEGURA ANTI-CRASH
function createGardenTree(px, pz) {
  // 1. Prote√ß√£o de √°rea
  const distX = Math.abs(px - cx);
  const distZ = Math.abs(pz - cz);
  if (distX > 5.0 || distZ > 5.0) return;
  for (const bench of benchPositions) {
    if (Math.hypot(px - bench.x, pz - bench.z) < 2.2) return;
  }

  const group = new THREE.Group();
  const size = 6.0 + Math.random() * 3.0; 
  
  const trunkMat = new THREE.MeshLambertMaterial({ color: 0x5d4037 });
  const leavesMat = new THREE.MeshLambertMaterial({ color: 0x2e7d32, flatShading: true });

  // Configura√ß√£o da Fruta
  const hasFruit = Math.random() > 0.3;
  let fruitColor = 0xff0000;
  if (hasFruit) {
    const r = Math.random();
    fruitColor = r < 0.33 ? 0xffa500 : (r < 0.66 ? 0xff0000 : 0xffd700);
  }

  // Fun√ß√£o interna: Cria o mesh da fruta
  function createDetailedFruit() {
    const fGroup = new THREE.Group();
    const body = new THREE.Mesh(
      new THREE.SphereGeometry(0.15, 8, 8),
      new THREE.MeshLambertMaterial({ color: fruitColor })
    );
    fGroup.add(body);
    const stem = new THREE.Mesh(
      new THREE.CylinderGeometry(0.02, 0.02, 0.1, 4),
      new THREE.MeshLambertMaterial({ color: 0x3e2723 })
    );
    stem.position.y = 0.15; 
    fGroup.add(stem);
    return fGroup;
  }

  // TRONCO
  const trunkH = size * 0.65; 
  const trunkR = 0.25;
  const trunkGeo = new THREE.CylinderGeometry(trunkR * 0.7, trunkR, trunkH, 7);
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.name = "tree_trunk"; // <--- ETIQUETA PARA COLIS√ÉO
  trunk.position.y = trunkH / 2;
  trunk.castShadow = true;
  trunk.receiveShadow = true;
  group.add(trunk);

  // GALHOS E COPA
  const numBranches = 5 + Math.floor(Math.random() * 3);
  
  for(let i=0; i<numBranches; i++) {
    const branchLen = trunkH * 0.4;
    const branchGeo = new THREE.CylinderGeometry(trunkR * 0.3, trunkR * 0.5, branchLen, 5);
    branchGeo.translate(0, branchLen / 2, 0);

    const branch = new THREE.Mesh(branchGeo, trunkMat);
    const yPos = trunkH * (0.5 + Math.random() * 0.45);
    branch.position.set(0, yPos, 0);
    
    const angleY = (i / numBranches) * Math.PI * 2 + (Math.random() * 0.5);
    branch.rotation.y = angleY;
    branch.rotation.z = Math.PI / 3.5;
    branch.translateZ(trunkR * 0.5);

    // TUFO DE FOLHAS
    const leafGeo = new THREE.IcosahedronGeometry(1, 0);
    const tuft = new THREE.Mesh(leafGeo, leavesMat);
    tuft.position.set(0, branchLen, 0);
    const s = 0.8 + Math.random() * 0.6;
    tuft.scale.set(s, s, s);
    tuft.castShadow = true;
    
    // --- FRUTAS COM COLIS√ÉO ---
    if (hasFruit) {
      const fruitsInTuft = 2 + Math.floor(Math.random() * 3); 
      const placedPositions = []; // Guarda onde j√° pusemos fruta neste tufo
      
      for(let k=0; k<fruitsInTuft; k++) {
        let attempts = 0;
        let validPos = false;
        let finalPos = new THREE.Vector3();
        
        // Tenta achar um lugar vazio 10 vezes
        while(!validPos && attempts < 10) {
            attempts++;
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const rFruit = 0.75; 

            finalPos.set(
              rFruit * Math.sin(phi) * Math.cos(theta),
              rFruit * Math.sin(phi) * Math.sin(theta),
              rFruit * Math.cos(phi)
            );
            
            // Verifica dist√¢ncia das outras frutas
            let tooClose = false;
            for(const p of placedPositions) {
                if(p.distanceTo(finalPos) < 0.4) { // Dist√¢ncia m√≠nima de 0.4
                    tooClose = true;
                    break;
                }
            }
            
            if(!tooClose) validPos = true;
        }

        // Se achou lugar, cria a fruta
        if (validPos) {
            const fruit = createDetailedFruit();
            fruit.position.copy(finalPos);
            fruit.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
            tuft.add(fruit);
            placedPositions.push(finalPos);
        }
      }
    }

    branch.add(tuft);
    group.add(branch);
  }
  
  // TUFO DO TOPO (Tamb√©m com colis√£o de frutas)
  const topTuft = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 0), leavesMat);
  topTuft.position.y = trunkH;
  topTuft.scale.set(1.6, 1.6, 1.6);
  
  if (hasFruit) {
      const topPlaced = [];
      for(let k=0; k<5; k++) {
        let attempts = 0;
        let valid = false;
        let pos = new THREE.Vector3();
        
        while(!valid && attempts < 10) {
            attempts++;
            pos.set(
                (Math.random()-0.5)*1.2,
                (Math.random()-0.5)*1.2,
                (Math.random()-0.5)*1.2
            );
            let cl = false;
            for(const p of topPlaced) if(p.distanceTo(pos) < 0.4) cl = true;
            if(!cl) valid = true;
        }
        
        if(valid) {
            const fruit = createDetailedFruit();
            fruit.position.copy(pos);
            fruit.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
            topTuft.add(fruit);
            topPlaced.push(pos);
        }
      }
  }
  group.add(topTuft);

  group.position.set(px, 0, pz);
  group.rotation.y = Math.random() * Math.PI;
  scene.add(group);
}
      
      // --- √ÅRVORES RANDOMIZADAS (0 a 4 por jardim) ---
      
      // 1. Define posi√ß√µes seguras onde √°rvores podem nascer (longe da mesa e cal√ßadas)
      const possibleSpots = [
        { x: cx - 3.5, z: cz - 3.5 }, // Canto Superior Esquerdo
        { x: cx + 3.5, z: cz - 3.5 }, // Canto Superior Direito
        { x: cx - 3.5, z: cz + 3.5 }, // Canto Inferior Esquerdo
        { x: cx + 3.5, z: cz + 3.5 }, // Canto Inferior Direito
        { x: cx,       z: cz - 4.0 }, // Norte (atr√°s do banco)
        { x: cx,       z: cz + 4.0 }, // Sul (atr√°s do banco)
        { x: cx - 4.0, z: cz },       // Oeste
        { x: cx + 4.0, z: cz }        // Leste
      ];

      // 2. Embaralha a lista de posi√ß√µes (Shuffle)
      for (let i = possibleSpots.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [possibleSpots[i], possibleSpots[j]] = [possibleSpots[j], possibleSpots[i]];
      }

      // 3. Sorteia a quantidade (Entre 0 e 4)
      // Math.random() * 5 gera um n√∫mero entre 0 e 4.99... o floor arredonda para 0, 1, 2, 3 ou 4.
      const treeCount = Math.floor(Math.random() * 5);

      // 4. Cria as √°rvores nas primeiras 'treeCount' posi√ß√µes da lista embaralhada
      for(let i = 0; i < treeCount; i++) {
        createGardenTree(possibleSpots[i].x, possibleSpots[i].z);
      }
      
      // --- CERCA VIVA (Arbustos Naturais) ---

    }

    // Helper function to check if a position is on or too close to roads/sidewalks
    function isOnRoad(x, z) {
      const roadThreshold = ROAD_W / 2 + SIDEWALK_W + 1.0; // Add 1.0 buffer beyond sidewalk
      
      for (let i = -3; i <= 3; i++) {
        const roadX = i * BLOCK_SIZE;
        const roadZ = i * BLOCK_SIZE;
        
        // Check if too close to vertical roads
        if (Math.abs(x - roadX) < roadThreshold) return true;
        
        // Check if too close to horizontal roads  
        if (Math.abs(z - roadZ) < roadThreshold) return true;
      }
      
      return false;
    }

    // Fun√ß√£o para verificar se uma posi√ß√£o est√° livre
    function isSpotFree(x, z, radius = 1.5) {
      for (const p of occupiedSpots) {
        const dist = Math.hypot(x - p.x, z - p.z);
        if (dist < radius) return false; // J√° tem algo aqui
      }
      return true;
    }

    // Main city generation function
    // 5. Fun√ß√£o createCityV2 Atualizada (Aplica tudo)
    function createCityV2() {
      clearOldCity();
      occupiedSpots = []; // Limpa posi√ß√µes ocupadas
      
      const gridSize = 5; // 5x5 intersections
      const spacing = BLOCK_SIZE; // 16
      const offset = (gridSize - 1) * spacing / 2;

      // Cria o Grid de Ruas
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          const x = c * spacing - offset;
          const z = r * spacing - offset;
          
          // Cria Cruzamento no n√≥
          createIntersection(x, z);

          // Cria Rua para a Direita (Se n√£o for √∫ltima coluna)
          if (c < gridSize - 1) {
            createRoadSegment(x + spacing/2, z, true);
          }
          // Cria Rua para Baixo (Se n√£o for √∫ltima linha)
          if (r < gridSize - 1) {
            createRoadSegment(x, z + spacing/2, false);
          }
        }
      }

      // Preenche os Quarteir√µes (Buracos do grid)
      // Grid de ruas √© 5x5, ent√£o temos 4x4 quarteir√µes
      for (let r = 0; r < gridSize - 1; r++) {
        for (let c = 0; c < gridSize - 1; c++) {
          const cx = (c * spacing - offset) + spacing/2;
          const cz = (r * spacing - offset) + spacing/2;

          // Centro (Pra√ßa) - REMOVIDO: Agora √© um bloco normal
          // if (Math.abs(cx) < 2 && Math.abs(cz) < 2) {
          //   // Centro vazio ou especial
          //   continue;
          // }

          // --- CORRE√á√ÉO DO QUADRADO CINZA ---
          // Se for o bloco central (0,0), PULA TUDO. N√£o cria cal√ßada, nem pr√©dio.
          if (Math.abs(cx) < 1.0 && Math.abs(cz) < 1.0) {
            continue; 
          }
          createBlockSidewalks(cx, cz);

          // Decide Pr√©dio, Casa ou Jardim
          const isGarden = (Math.abs(r) >= 1 && Math.abs(c) >= 1) || (r+c)%2===0;
          
          if (isGarden) createGarden(cx, cz);
          else {
             // Paleta de Reciclagem - CORES VIVAS
             const buildingColors = [
               0xef5350, // Vermelho (Pl√°stico)
               0x42a5f5, // Azul (Papel)
               0x66bb6a, // Verde (Vidro)
               0xffee58  // Amarelo (Metal)
             ];
             
             const clr = buildingColors[Math.floor(Math.random()*buildingColors.length)];
             
             // Garantir pelo menos 3 casas e 3 pr√©dios - usar contadores globais
             if (typeof window.houseCount === 'undefined') window.houseCount = 0;
             if (typeof window.buildingCount === 'undefined') window.buildingCount = 0;
             if (typeof window.buildingSlots === 'undefined') window.buildingSlots = 0;
             window.buildingSlots++;
             
             // L√≥gica: 
             // - Se ainda n√£o tem 3 casas, for√ßar casa
             // - Se ainda n√£o tem 3 pr√©dios, for√ßar pr√©dio
             // - Se ambos m√≠nimos atingidos, 40% chance casa / 60% chance pr√©dio
             let makeHouse = false;
             
             if (window.houseCount < 3 && window.buildingCount < 3) {
               // Ambos precisam de mais - alternar baseado no slot
               makeHouse = (window.buildingSlots % 2 === 1);
             } else if (window.houseCount < 3) {
               // Precisa de mais casas
               makeHouse = true;
             } else if (window.buildingCount < 3) {
               // Precisa de mais pr√©dios
               makeHouse = false;
             } else {
               // M√≠nimos atingidos - aleat√≥rio
               makeHouse = Math.random() < 0.4;
             }
             
             if (makeHouse) {
               createHouse(cx, cz, clr);
               window.houseCount++;
             } else {
               const h = 8 + Math.floor(Math.random() * 12);
               createBuilding(cx, cz, h, clr);
               window.buildingCount++;
             }
          }
          
          // Placas de PARE (nas esquinas da cal√ßada, offset 5.25)
          if (Math.random() > 0.6) {
             const px = cx - 5.25; 
             const pz = cz - 5.25;
             if (isSpotFree(px, pz)) {
                 createStopSign(px, pz, 0);
                 occupiedSpots.push({x: px, z: pz});
             }
          }

          // --- CORRE√á√ÉO DOS HIDRANTES ---
          // --- POSTES DE LUZ (Fartos e nas Esquinas) ---
          // Mant√©m 2 garantidos (diagonal) e 50% de chance para os outros 2
          const postOff = 4.5; 
          const corners = [
              { x: cx - postOff, z: cz - postOff, rot: -Math.PI/4, always: true },   // SW
              { x: cx + postOff, z: cz + postOff, rot: 3*Math.PI/4, always: true },  // NE
              { x: cx - postOff, z: cz + postOff, rot: -3*Math.PI/4, always: false },// NW
              { x: cx + postOff, z: cz - postOff, rot: Math.PI/4, always: false }    // SE
          ];

          corners.forEach(c => {
             if (c.always || Math.random() > 0.5) {
                 if (isSpotFree(c.x, c.z)) {
                     createLampPost(c.x, c.z, c.rot);
                     occupiedSpots.push({x: c.x, z: c.z});
                 }
             }
          });

          // --- HIDRANTES (Esquinas da Cal√ßada) ---
          // Chance de 50% por bloco
          if (Math.random() > 0.5) { 
              // Offset 3.8: Coloca no meio da largura da cal√ßada, bem na curva da esquina
              const hOff = 3.8; 
              
              // Lista das 4 esquinas poss√≠veis
              const hSpots = [
                 {x: cx - hOff, z: cz - hOff}, // SW
                 {x: cx + hOff, z: cz - hOff}, // SE
                 {x: cx - hOff, z: cz + hOff}, // NW
                 {x: cx + hOff, z: cz + hOff}  // NE
              ];
              
              // Embaralha para tentar cantos aleat√≥rios
              hSpots.sort(() => Math.random() - 0.5);
              
              // Procura um canto que esteja LIVRE (sem poste e sem placa)
              for (let i = 0; i < hSpots.length; i++) {
                  const spot = hSpots[i];
                  
                  // Raio de verifica√ß√£o 1.0 para garantir que n√£o cole no poste
                  if (isSpotFree(spot.x, spot.z, 1.0)) {
                      createHydrant(spot.x, spot.z);
                      occupiedSpots.push({x: spot.x, z: spot.z});
                      break; // Coloca apenas 1 e para
                  }
              }
          }
        }
      }

      rebuildStaticColliders();
    }

    // ==========================
    // CLOUD SYSTEM
    // ==========================

function createCloudSystem() {
  const cloudCount = 80; // Mais nuvens para preencher duas camadas
  const cloudGeo = new THREE.IcosahedronGeometry(1, 0); 
  const cloudMat = new THREE.MeshBasicMaterial({ 
    color: 0xffffff, 
    transparent: true, 
    opacity: 0.8
  });

  for(let i=0; i<cloudCount; i++) {
    const group = new THREE.Group();
    
    // Cria o corpo da nuvem (Aglomerado)
    const core = new THREE.Mesh(cloudGeo, cloudMat);
    core.scale.set(1.8, 1.4, 1.8);
    group.add(core);

    const numPuffs = 4 + Math.floor(Math.random() * 5);
    for(let j=0; j<numPuffs; j++) {
      const puff = new THREE.Mesh(cloudGeo, cloudMat);
      puff.position.set(
        (Math.random() - 0.5) * 3.0,
        (Math.random() - 0.3) * 1.5,
        (Math.random() - 0.5) * 2.0
      );
      const s = 0.8 + Math.random() * 0.8;
      puff.scale.setScalar(s);
      puff.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
      group.add(puff);
    }

    // L√≥gica de Camadas (Alta vs Baixa)
    const isLow = Math.random() > 0.6; // 40% de chance de ser baixa
    let posY;
    
    if (isLow) {
       // Camada Baixa (Horizonte): Entre 18 e 28 (Logo acima dos pr√©dios)
       posY = 18 + Math.random() * 10;
    } else {
       // Camada Alta (C√©u): Entre 45 e 80
       posY = 45 + Math.random() * 35;
    }

    // Posiciona
    group.position.set(
      (Math.random() - 0.5) * 400, 
      posY,     
      (Math.random() - 0.5) * 400  
    );
    
    // Salva se √© baixa ou alta para o respawn manter a l√≥gica
    group.userData = { 
      speed: 0.5 + Math.random() * 1.5,
      isLow: isLow
    };
    
    scene.add(group);
    clouds.push(group);
  }
}

    // ==========================
    // T√öNEIS NAS BORDAS DO MAPA
    // ==========================

    function createTunnels() {
      // --- MATERIAIS ---
      const concreteMat = new THREE.MeshPhongMaterial({ color: 0x999999, flatShading: true, shininess: 5 });
      const voidMat     = new THREE.MeshBasicMaterial({ color: 0x000000 }); 
      const roadMat     = new THREE.MeshLambertMaterial({ color: 0x222222 });
      const stripeMat   = new THREE.MeshBasicMaterial({ color: 0xffcc00 }); 
      const lightMat    = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
      const lineMat     = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const grassMat    = new THREE.MeshLambertMaterial({ color: 0x2e7d32 }); // Grama

      // Materiais da Paisagem (Montanhas de fundo)
      const mountMat = new THREE.MeshLambertMaterial({ color: 0x1b5e20, flatShading: true }); 
      const rockMat  = new THREE.MeshLambertMaterial({ color: 0x546e7a, flatShading: true });

      const limit = 47; 
      const cityEdge = 32; // Borda real da cidade (√∫ltima interse√ß√£o do grid 5x5) 

      // === FUN√á√ÉO PARA T√öNEL COMPLETO ===
      function spawnTunnel(x, z, rotY, isMain) {
        const group = new THREE.Group();

        // Configura√ß√£o de Tamanho
        const w = isMain ? 10.0 : 7.5; 
        const h = isMain ? 7.0  : 5.0;
        const d = 6.0;
        const wallLength = 60; // Comprimento das paredes at√© as montanhas

        // 1. ESTRUTURA FRONTAL (Entrada do t√∫nel)
        const struct = new THREE.Group();
        
        // Pilares frontais
        const pL = new THREE.Mesh(new THREE.BoxGeometry(2.0, h, d), concreteMat);
        pL.position.set(-(w/2 + 1.0), h/2, 0);
        struct.add(pL);

        const pR = new THREE.Mesh(new THREE.BoxGeometry(2.0, h, d), concreteMat);
        pR.position.set((w/2 + 1.0), h/2, 0);
        struct.add(pR);

        // Teto (Diferente para Main vs Small)
        if (isMain) {
            const roof = new THREE.Mesh(new THREE.BoxGeometry(w + 5, 1.5, d), concreteMat);
            roof.position.set(0, h + 0.75, 0);
            struct.add(roof);
            
            const arch = new THREE.Mesh(
                new THREE.CylinderGeometry(w/2, w/2, d, 32, 1, true, 0, Math.PI),
                new THREE.MeshPhongMaterial({color:0x777777, side:THREE.DoubleSide})
            );
            arch.rotation.set(Math.PI/2, Math.PI/2, Math.PI/2);
            arch.position.set(0, h - 0.5, 0);
            struct.add(arch);
            
            const sign = new THREE.Mesh(new THREE.BoxGeometry(4, 0.8, 0.1), new THREE.MeshLambertMaterial({color: 0x0033cc}));
            sign.position.set(0, h + 2, 1.0); 
            struct.add(sign);
        } else {
            const roof = new THREE.Mesh(new THREE.BoxGeometry(w + 4, 1.0, d), concreteMat);
            roof.position.set(0, h + 0.5, 0);
            struct.add(roof);
            
            const sign = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.6, 0.1), new THREE.MeshLambertMaterial({color: 0x0033cc}));
            sign.position.set(0, h + 0.6, 1.0); 
            struct.add(sign);
        }
        
        group.add(struct);

        // 2. PAREDES LATERAIS ESTENDIDAS (V√£o at√© as montanhas)
        const wallH = h + 2;
        const wallThickness = 2.0;
        
        // Parede esquerda estendida
        const wallL = new THREE.Mesh(
            new THREE.BoxGeometry(wallThickness, wallH, wallLength), 
            concreteMat
        );
        wallL.position.set(-(w/2 + 1.0), wallH/2, -wallLength/2);
        group.add(wallL);
        
        // Parede direita estendida
        const wallR = new THREE.Mesh(
            new THREE.BoxGeometry(wallThickness, wallH, wallLength), 
            concreteMat
        );
        wallR.position.set((w/2 + 1.0), wallH/2, -wallLength/2);
        group.add(wallR);

        // Teto estendido do t√∫nel
        const roofExt = new THREE.Mesh(
            new THREE.BoxGeometry(w + 4, 1.0, wallLength), 
            concreteMat
        );
        roofExt.position.set(0, wallH, -wallLength/2);
        group.add(roofExt);

        // CAL√áADAS DE CONCRETO nas laterais da rua (dentro do t√∫nel)
        // A rua tem 7m de largura (-3.5 a +3.5), paredes em ¬±6
        // Cal√ßadas preenchem o espa√ßo entre a rua e as paredes
        const sidewalkMat = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
        const roadHalfWidth = 3.5; // Metade da largura da rua
        const wallPos = w/2 + 1.0; // Posi√ß√£o da parede (6m do centro)
        const sidewalkWidth = wallPos - roadHalfWidth; // Largura da cal√ßada (~2.5m)
        const sidewalkHeight = 0.15; // Altura da cal√ßada
        
        // Cal√ßada esquerda (entre a rua e a parede esquerda)
        const sidewalkL = new THREE.Mesh(
            new THREE.BoxGeometry(sidewalkWidth, sidewalkHeight, wallLength + 10),
            sidewalkMat
        );
        // Posiciona elevada acima da rua (base em Y=0.01, topo em Y=0.16)
        sidewalkL.position.set(-(roadHalfWidth + sidewalkWidth/2), sidewalkHeight/2 + 0.01, -wallLength/2);
        group.add(sidewalkL);
        
        // Cal√ßada direita (entre a rua e a parede direita)
        const sidewalkR = new THREE.Mesh(
            new THREE.BoxGeometry(sidewalkWidth, sidewalkHeight, wallLength + 10),
            sidewalkMat
        );
        sidewalkR.position.set((roadHalfWidth + sidewalkWidth/2), sidewalkHeight/2 + 0.01, -wallLength/2);
        group.add(sidewalkR);

        // Meio-fio (borda da cal√ßada junto √† rua)
        const curbMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
        const curbWidth = 0.12;
        const curbHeight = 0.18; // Ligeiramente menor que a cal√ßada
        
        // Meio-fio esquerdo (na borda da rua) - elevado acima da cal√ßada para evitar z-fighting
        const curbL = new THREE.Mesh(
            new THREE.BoxGeometry(curbWidth, curbHeight, wallLength + 10),
            curbMat
        );
        curbL.position.set(-roadHalfWidth - curbWidth/2, sidewalkHeight + curbHeight/2 + 0.02, -wallLength/2);
        group.add(curbL);
        
        // Meio-fio direito (na borda da rua) - elevado acima da cal√ßada para evitar z-fighting
        const curbR = new THREE.Mesh(
            new THREE.BoxGeometry(curbWidth, curbHeight, wallLength + 10),
            curbMat
        );
        curbR.position.set(roadHalfWidth + curbWidth/2, sidewalkHeight + curbHeight/2 + 0.02, -wallLength/2);
        group.add(curbR);

        // 3. DETALHES FRONTAIS
        const stL = new THREE.Mesh(new THREE.BoxGeometry(1.2, h - 1, 0.1), stripeMat);
        stL.position.set(-(w/2 + 1.0), h/2, d/2 + 0.05); 
        group.add(stL);
        const stR = stL.clone();
        stR.position.set((w/2 + 1.0), h/2, d/2 + 0.05); 
        group.add(stR);

        if (isMain) {
            const lamp = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.2, 0.5), lightMat);
            lamp.position.set(0, h + 1, 0); 
            group.add(lamp);
        }

        // 4. INTERIOR - ESCURID√ÉO TOTAL no fundo do t√∫nel
        // Apenas uma PAREDE PRETA no fundo para esconder o que est√° atr√°s
        // Tamanho contido dentro das paredes do t√∫nel
        
        const backWall = new THREE.Mesh(
            new THREE.PlaneGeometry(w, wallH),
            voidMat
        );
        backWall.position.set(0, wallH/2, -20);
        group.add(backWall);

        // 5. ESCURID√ÉO TOTAL garantida

        // 6. CH√ÉO DE GRAMA ao redor do t√∫nel
        // Lado esquerdo
        const grassL = new THREE.Mesh(
            new THREE.PlaneGeometry(30, wallLength + 20), 
            grassMat
        );
        grassL.rotation.x = -Math.PI / 2;
        grassL.position.set(-(w/2 + 1.0 + 16), -0.1, -wallLength/2);
        group.add(grassL);

        // Lado direito
        const grassR = new THREE.Mesh(
            new THREE.PlaneGeometry(30, wallLength + 20), 
            grassMat
        );
        grassR.rotation.x = -Math.PI / 2;
        grassR.position.set((w/2 + 1.0 + 16), -0.1, -wallLength/2);
        group.add(grassR);

        // Posiciona o grupo todo
        group.position.set(x, 0, z);
        group.rotation.y = rotY;
        scene.add(group);
      }

      // Fun√ß√£o de Estrada de Conex√£o
      function connectRoad(startX, startZ, endX, endZ, isHorizontal) {
        const len = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endZ - startZ, 2));
        const midX = (startX + endX) / 2;
        const midZ = (startZ + endZ) / 2;
        const roadW = 7.0; 

        const road = new THREE.Mesh(
            new THREE.PlaneGeometry(isHorizontal ? len : roadW, isHorizontal ? roadW : len),
            roadMat
        );
        road.rotation.x = -Math.PI / 2;
        road.position.set(midX, 0.03, midZ);
        scene.add(road);

        const dashCount = Math.floor(len / 3);
        for(let i=0; i<dashCount; i++) {
            const dash = new THREE.Mesh(new THREE.PlaneGeometry(0.2, 1.5), lineMat);
            dash.rotation.x = -Math.PI / 2;
            if (isHorizontal) {
                dash.rotation.z = Math.PI / 2;
                dash.position.set(startX + (endX-startX)*(i+0.5)/dashCount, 0.04, midZ);
            } else {
                dash.position.set(midX, 0.04, startZ + (endZ-startZ)*(i+0.5)/dashCount);
            }
            scene.add(dash);
        }
      }

      // === GERAR T√öNEIS ===
      const roads = [0];

      roads.forEach(pos => {
          const isMain = (pos === 0);

          // Oeste - apenas t√∫nel (a extens√£o de rua j√° conecta)
          spawnTunnel(-limit, pos, Math.PI / 2, isMain);
          
          // Leste - apenas t√∫nel
          spawnTunnel(limit, pos, -Math.PI / 2, isMain);
          
          // Norte - apenas t√∫nel
          spawnTunnel(pos, -limit, 0, isMain);
          
          // Sul - apenas t√∫nel
          spawnTunnel(pos, limit, Math.PI, isMain);
      });

      // === EXTENS√ïES DAS RUAS DA CIDADE AT√â O FINAL DOS T√öNEIS ===
      // Cria segmentos de asfalto conectando a √∫ltima interse√ß√£o (32) at√© o final do t√∫nel (47 + 60 = 107)
      const extRoadMat = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
      const extLineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const tunnelRoadLength = 80; // Comprimento total da rua (32 at√© ~112)
      
      // Rua cont√≠nua Oeste (de -32 at√© o final do t√∫nel) - horizontal
      const roadWest = new THREE.Mesh(new THREE.PlaneGeometry(tunnelRoadLength, 7), extRoadMat);
      roadWest.rotation.x = -Math.PI / 2;
      roadWest.position.set(-32 - tunnelRoadLength/2, 0.006, 0); // Altura menor para ficar abaixo da rua da cidade
      scene.add(roadWest);
      
      // Faixas tracejadas Oeste
      for (let i = 0; i < 25; i++) {
          const dash = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.15), extLineMat);
          dash.rotation.x = -Math.PI / 2;
          dash.position.set(-33 - i * 3, 0.015, 0);
          scene.add(dash);
      }
      
      // Rua cont√≠nua Leste (de 32 at√© o final do t√∫nel) - horizontal
      const roadEast = new THREE.Mesh(new THREE.PlaneGeometry(tunnelRoadLength, 7), extRoadMat);
      roadEast.rotation.x = -Math.PI / 2;
      roadEast.position.set(32 + tunnelRoadLength/2, 0.006, 0);
      scene.add(roadEast);
      
      // Faixas tracejadas Leste
      for (let i = 0; i < 25; i++) {
          const dash = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.15), extLineMat);
          dash.rotation.x = -Math.PI / 2;
          dash.position.set(33 + i * 3, 0.015, 0);
          scene.add(dash);
      }
      
      // Rua cont√≠nua Norte (de -32 at√© o final do t√∫nel) - vertical
      const roadNorth = new THREE.Mesh(new THREE.PlaneGeometry(7, tunnelRoadLength), extRoadMat);
      roadNorth.rotation.x = -Math.PI / 2;
      roadNorth.position.set(0, 0.006, -32 - tunnelRoadLength/2);
      scene.add(roadNorth);
      
      // Faixas tracejadas Norte
      for (let i = 0; i < 25; i++) {
          const dash = new THREE.Mesh(new THREE.PlaneGeometry(0.15, 1.5), extLineMat);
          dash.rotation.x = -Math.PI / 2;
          dash.position.set(0, 0.015, -33 - i * 3);
          scene.add(dash);
      }
      
      // Rua cont√≠nua Sul (de 32 at√© o final do t√∫nel) - vertical
      const roadSouth = new THREE.Mesh(new THREE.PlaneGeometry(7, tunnelRoadLength), extRoadMat);
      roadSouth.rotation.x = -Math.PI / 2;
      roadSouth.position.set(0, 0.006, 32 + tunnelRoadLength/2);
      scene.add(roadSouth);
      
      // Faixas tracejadas Sul
      for (let i = 0; i < 25; i++) {
          const dash = new THREE.Mesh(new THREE.PlaneGeometry(0.15, 1.5), extLineMat);
          dash.rotation.x = -Math.PI / 2;
          dash.position.set(0, 0.015, 33 + i * 3);
          scene.add(dash);
      }

      // === CONCRETO REMOVIDO - MANTIDO APENAS DENTRO DOS T√öNEIS ===

      // === CH√ÉO DE GRAMA EXTRA (Preencher cantos) ===
      // Quadrantes de grama nos cantos do mapa
      const cornerSize = 50;
      const cornerDist = 70;
      
      [[-1,-1], [-1,1], [1,-1], [1,1]].forEach(([sx, sz]) => {
          const corner = new THREE.Mesh(
              new THREE.PlaneGeometry(cornerSize, cornerSize),
              grassMat
          );
          corner.rotation.x = -Math.PI / 2;
          corner.position.set(sx * cornerDist, -0.2, sz * cornerDist);
          scene.add(corner);
      });
    }

    function createLandscape() {
      // Materiais da Paisagem - Tons de Minas Gerais
      const serraVerde = new THREE.MeshLambertMaterial({ color: 0x2d5a27, flatShading: true }); 
      const serraEscura = new THREE.MeshLambertMaterial({ color: 0x1e4620, flatShading: true }); 
      const serraClara = new THREE.MeshLambertMaterial({ color: 0x3d7a37, flatShading: true }); 
      const mataCiliar = new THREE.MeshLambertMaterial({ color: 0x4a8f44, flatShading: true });
      const terraMat = new THREE.MeshLambertMaterial({ color: 0x8B4513, flatShading: true }); // Terra vermelha mineira
      const grassMat = new THREE.MeshLambertMaterial({ color: 0x2e7d32 });

      // Dist√¢ncia do anel de serras
      const radius = 105; 
      const mountainCount = 50;
      
      // Dire√ß√µes dos t√∫neis (onde N√ÉO colocar montanhas)
      // T√∫neis est√£o em: Norte (z=-), Sul (z+), Leste (x+), Oeste (x-)
      const tunnelWidth = 30; // Largura da abertura para o t√∫nel (aumentado para cobrir toda a vis√£o)

      for (let i = 0; i < mountainCount; i++) {
        const angle = (i / mountainCount) * Math.PI * 2;
        const rVar = radius + (Math.random() * 30); 
        
        const x = Math.cos(angle) * rVar;
        const z = Math.sin(angle) * rVar;
        
        // Verificar se est√° na dire√ß√£o de um t√∫nel
        // T√∫nel Norte: z muito negativo, x perto de 0
        // T√∫nel Sul: z muito positivo, x perto de 0
        // T√∫nel Leste: x muito positivo, z perto de 0
        // T√∫nel Oeste: x muito negativo, z perto de 0
        const isInTunnelPath = (
          (Math.abs(x) < tunnelWidth && z < -50) || // Norte
          (Math.abs(x) < tunnelWidth && z > 50) ||  // Sul
          (Math.abs(z) < tunnelWidth && x > 50) ||  // Leste
          (Math.abs(z) < tunnelWidth && x < -50)    // Oeste
        );
        
        if (isInTunnelPath) continue; // Pula esta montanha

        // Serras mineiras - mais largas e arredondadas
        const isBig = Math.random() > 0.4;
        const height = isBig ? 25 + Math.random() * 18 : 15 + Math.random() * 12;
        const baseWidth = height * (0.7 + Math.random() * 0.3); // Mais largas
        
        // Grupo da serra
        const serraGroup = new THREE.Group();
        serraGroup.position.set(x, 0, z);
        serraGroup.rotation.y = Math.random() * Math.PI * 2;
        
        // Material variado - tons de verde da mata atl√¢ntica
        const matChoice = Math.random();
        let mat;
        if (matChoice > 0.7) mat = serraClara;
        else if (matChoice > 0.4) mat = serraVerde;
        else mat = serraEscura;
        
        // Serra principal - cone mais achatado (serras arredondadas)
        const serraGeo = new THREE.ConeGeometry(baseWidth, height, 8);
        const serra = new THREE.Mesh(serraGeo, mat);
        serra.position.y = height / 2 - 5;
        serraGroup.add(serra);
        
        // Adiciona "morros" menores ao redor (caracter√≠stica das serras mineiras)
        const morroCount = Math.floor(Math.random() * 3) + 1;
        for (let m = 0; m < morroCount; m++) {
          const morroH = height * (0.3 + Math.random() * 0.3);
          const morroW = morroH * (0.8 + Math.random() * 0.3);
          const morroAngle = (m / morroCount) * Math.PI * 2 + Math.random() * 0.5;
          const morroDist = baseWidth * (0.5 + Math.random() * 0.3);
          
          const morroGeo = new THREE.ConeGeometry(morroW, morroH, 6);
          const morroMat = Math.random() > 0.5 ? serraVerde : mataCiliar;
          const morro = new THREE.Mesh(morroGeo, morroMat);
          morro.position.set(
            Math.cos(morroAngle) * morroDist,
            morroH / 2 - 3,
            Math.sin(morroAngle) * morroDist
          );
          serraGroup.add(morro);
        }
        
        scene.add(serraGroup);

        // Serras secund√°rias (cordilheiras)
        if (Math.random() > 0.5) {
          const subH = height * (0.4 + Math.random() * 0.25);
          const subW = subH * 0.8;
          
          const subAngle = angle + (Math.random() - 0.5) * 0.18;
          const subR = rVar + (Math.random() - 0.5) * 18;
          
          const subX = Math.cos(subAngle) * subR;
          const subZ = Math.sin(subAngle) * subR;
          
          const subGroup = new THREE.Group();
          subGroup.position.set(subX, 0, subZ);
          subGroup.rotation.y = Math.random() * Math.PI;
          
          const subMat = Math.random() > 0.5 ? serraEscura : serraVerde;
          const subGeo = new THREE.ConeGeometry(subW, subH, 6);
          const sub = new THREE.Mesh(subGeo, subMat);
          sub.position.y = subH / 2 - 3;
          subGroup.add(sub);
          
          // Verificar se est√° na dire√ß√£o de um t√∫nel
          const isSubInTunnelPath = (
            (Math.abs(subX) < tunnelWidth && subZ < -50) ||
            (Math.abs(subX) < tunnelWidth && subZ > 50) ||
            (Math.abs(subZ) < tunnelWidth && subX > 50) ||
            (Math.abs(subZ) < tunnelWidth && subX < -50)
          );
          
          if (!isSubInTunnelPath) {
            scene.add(subGroup);
          }
        }
      }
      
      // Adiciona algumas serras mais distantes (horizonte)
      for (let i = 0; i < 25; i++) {
        const angle = (i / 25) * Math.PI * 2;
        const dist = 145 + Math.random() * 20;
        const x = Math.cos(angle) * dist;
        const z = Math.sin(angle) * dist;
        
        // Verificar se est√° na dire√ß√£o de um t√∫nel
        const isInTunnelPath = (
          (Math.abs(x) < tunnelWidth + 10 && z < -50) ||
          (Math.abs(x) < tunnelWidth + 10 && z > 50) ||
          (Math.abs(z) < tunnelWidth + 10 && x > 50) ||
          (Math.abs(z) < tunnelWidth + 10 && x < -50)
        );
        
        if (isInTunnelPath) continue;
        
        const h = 20 + Math.random() * 15;
        const w = h * 1.0;
        
        const geo = new THREE.ConeGeometry(w, h, 5);
        // Serras distantes s√£o mais azuladas (perspectiva atmosf√©rica)
        const distMat = new THREE.MeshLambertMaterial({ 
          color: new THREE.Color(0x3d6b47).lerp(new THREE.Color(0x5a7a8a), 0.3),
          flatShading: true 
        });
        const mesh = new THREE.Mesh(geo, distMat);
        mesh.position.set(x, h / 2 - 6, z);
        scene.add(mesh);
      }
      
      // Ch√£o verde principal - cobre TODO o exterior
      const farGround = new THREE.Mesh(
          new THREE.RingGeometry(42, 400, 64),
          grassMat
      );
      farGround.rotation.x = -Math.PI / 2;
      farGround.position.y = -0.3;
      scene.add(farGround);

      // Ch√£o extra nos cantos (quadrados para garantir cobertura)
      const extraGroundSize = 200;
      const extraGround = new THREE.Mesh(
          new THREE.PlaneGeometry(extraGroundSize, extraGroundSize),
          grassMat
      );
      extraGround.rotation.x = -Math.PI / 2;
      extraGround.position.y = -0.5;
      scene.add(extraGround);
      
      // ========== MONTANHAS ATR√ÅS DOS T√öNEIS ==========
      // Montanhas posicionadas nas laterais de cada t√∫nel (n√£o no centro para n√£o aparecer dentro)
      const tunnelEndDist = 100; // Onde o t√∫nel termina aproximadamente
      const tunnelMountainOffset = 18; // Offset lateral m√≠nimo (largura do t√∫nel √© ~10)
      
      // Fun√ß√£o para criar montanhas emoldurando a sa√≠da do t√∫nel
      function createTunnelMountains(dirX, dirZ) {
        const mountainMats = [serraVerde, serraEscura, serraClara];
        
        // Posi√ß√£o base (atr√°s do t√∫nel)
        const baseX = dirX * tunnelEndDist;
        const baseZ = dirZ * tunnelEndDist;
        const isHorizontal = dirX !== 0; // T√∫nel vai na dire√ß√£o X
        
        // Criar v√°rias montanhas em cada lado do t√∫nel
        for (let side = -1; side <= 1; side += 2) {
          // 3 montanhas por lado, de diferentes tamanhos
          for (let m = 0; m < 3; m++) {
            const h = 25 + Math.random() * 20 - m * 5;
            const w = h * (0.7 + Math.random() * 0.3);
            const mat = mountainMats[Math.floor(Math.random() * mountainMats.length)];
            
            // Offset lateral aumenta com cada montanha
            const lateralOffset = tunnelMountainOffset + m * 12 + Math.random() * 8;
            // Offset na dire√ß√£o do t√∫nel (varia√ß√£o)
            const depthOffset = (Math.random() - 0.5) * 20;
            
            let x, z;
            if (isHorizontal) {
              // T√∫nel vai em X, montanhas nos lados em Z
              x = baseX + depthOffset;
              z = side * lateralOffset;
            } else {
              // T√∫nel vai em Z, montanhas nos lados em X
              x = side * lateralOffset;
              z = baseZ + depthOffset;
            }
            
            const mountain = new THREE.Mesh(
              new THREE.ConeGeometry(w, h, 8),
              mat
            );
            mountain.position.set(x, h/2 - 5, z);
            scene.add(mountain);
            
            // Adiciona um morro menor ao lado
            if (Math.random() > 0.4) {
              const h2 = h * 0.5;
              const w2 = h2 * 0.8;
              const morro = new THREE.Mesh(
                new THREE.ConeGeometry(w2, h2, 6),
                mataCiliar
              );
              const morroOffsetLat = (Math.random() - 0.5) * 10;
              const morroOffsetDepth = (Math.random() - 0.5) * 10;
              if (isHorizontal) {
                morro.position.set(x + morroOffsetDepth, h2/2 - 3, z + side * 5 + morroOffsetLat);
              } else {
                morro.position.set(x + side * 5 + morroOffsetLat, h2/2 - 3, z + morroOffsetDepth);
              }
              scene.add(morro);
            }
          }
        }
        
        // Montanha central BEM ATR√ÅS do t√∫nel (n√£o vis√≠vel de dentro)
        const hBack = 35 + Math.random() * 15;
        const wBack = hBack * 0.9;
        const backDist = 30; // Dist√¢ncia extra para tr√°s
        const mountainBack = new THREE.Mesh(
          new THREE.ConeGeometry(wBack, hBack, 8),
          serraEscura
        );
        if (isHorizontal) {
          mountainBack.position.set(baseX + dirX * backDist, hBack/2 - 5, 0);
        } else {
          mountainBack.position.set(0, hBack/2 - 5, baseZ + dirZ * backDist);
        }
        scene.add(mountainBack);
      }
      
      // Montanhas nos 4 t√∫neis
      createTunnelMountains(0, -1);  // Norte
      createTunnelMountains(0, 1);   // Sul
      createTunnelMountains(1, 0);   // Leste
      createTunnelMountains(-1, 0);  // Oeste
      
      // ========== CERCAS E FLORESTAS ==========
      createFences();
      createForests();
    }
    
    function createFences() {
      // Materiais da cerca
      const woodMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Marrom madeira
      const darkWoodMat = new THREE.MeshLambertMaterial({ color: 0x5D3A1A }); // Marrom escuro
      
      const fenceDistance = 43; // Dist√¢ncia da cerca (antes da floresta)
      const roadHalfWidth = 5; // Espa√ßo para a estrada do t√∫nel
      const postSpacing = 3; // Espa√ßamento entre postes
      const fenceHeight = 1.2;
      const postRadius = 0.12;
      const railHeight = 0.08;
      const railDepth = 0.06;
      
      // Fun√ß√£o para criar um segmento de cerca
      function createFenceSegment(x1, z1, x2, z2) {
        const segmentGroup = new THREE.Group();
        
        // Calcula dire√ß√£o e comprimento
        const dx = x2 - x1;
        const dz = z2 - z1;
        const length = Math.sqrt(dx * dx + dz * dz);
        const angle = Math.atan2(dx, dz);
        
        // Poste inicial
        const post1Geo = new THREE.CylinderGeometry(postRadius, postRadius * 1.1, fenceHeight, 6);
        const post1 = new THREE.Mesh(post1Geo, darkWoodMat);
        post1.position.set(x1, fenceHeight / 2, z1);
        segmentGroup.add(post1);
        
        // Poste final
        const post2 = new THREE.Mesh(post1Geo, darkWoodMat);
        post2.position.set(x2, fenceHeight / 2, z2);
        segmentGroup.add(post2);
        
        // Topo pontiagudo dos postes
        const topGeo = new THREE.ConeGeometry(postRadius * 1.2, 0.15, 6);
        const top1 = new THREE.Mesh(topGeo, darkWoodMat);
        top1.position.set(x1, fenceHeight + 0.07, z1);
        segmentGroup.add(top1);
        
        const top2 = new THREE.Mesh(topGeo, darkWoodMat);
        top2.position.set(x2, fenceHeight + 0.07, z2);
        segmentGroup.add(top2);
        
        // Barras horizontais (2 n√≠veis)
        const centerX = (x1 + x2) / 2;
        const centerZ = (z1 + z2) / 2;
        
        // Barra superior
        const railGeo = new THREE.BoxGeometry(railDepth, railHeight, length);
        const rail1 = new THREE.Mesh(railGeo, woodMat);
        rail1.position.set(centerX, fenceHeight * 0.75, centerZ);
        rail1.rotation.y = angle;
        segmentGroup.add(rail1);
        
        // Barra inferior
        const rail2 = new THREE.Mesh(railGeo, woodMat);
        rail2.position.set(centerX, fenceHeight * 0.35, centerZ);
        rail2.rotation.y = angle;
        segmentGroup.add(rail2);
        
        return segmentGroup;
      }
      
      // ===== CERCA NORTE =====
      for (let x = -90; x < 90; x += postSpacing) {
        // Pula a √°rea da estrada
        if (x > -roadHalfWidth - postSpacing && x < roadHalfWidth) continue;
        
        const segment = createFenceSegment(x, -fenceDistance, x + postSpacing, -fenceDistance);
        scene.add(segment);
      }
      
      // ===== CERCA SUL =====
      for (let x = -90; x < 90; x += postSpacing) {
        if (x > -roadHalfWidth - postSpacing && x < roadHalfWidth) continue;
        
        const segment = createFenceSegment(x, fenceDistance, x + postSpacing, fenceDistance);
        scene.add(segment);
      }
      
      // ===== CERCA LESTE =====
      for (let z = -90; z < 90; z += postSpacing) {
        if (z > -roadHalfWidth - postSpacing && z < roadHalfWidth) continue;
        
        const segment = createFenceSegment(fenceDistance, z, fenceDistance, z + postSpacing);
        scene.add(segment);
      }
      
      // ===== CERCA OESTE =====
      for (let z = -90; z < 90; z += postSpacing) {
        if (z > -roadHalfWidth - postSpacing && z < roadHalfWidth) continue;
        
        const segment = createFenceSegment(-fenceDistance, z, -fenceDistance, z + postSpacing);
        scene.add(segment);
      }
      
      // ===== CANTOS (conecta as cercas) =====
      // Canto Nordeste
      scene.add(createFenceSegment(fenceDistance, -fenceDistance, fenceDistance - postSpacing, -fenceDistance));
      scene.add(createFenceSegment(fenceDistance, -fenceDistance, fenceDistance, -fenceDistance + postSpacing));
      
      // Canto Noroeste
      scene.add(createFenceSegment(-fenceDistance, -fenceDistance, -fenceDistance + postSpacing, -fenceDistance));
      scene.add(createFenceSegment(-fenceDistance, -fenceDistance, -fenceDistance, -fenceDistance + postSpacing));
      
      // Canto Sudeste
      scene.add(createFenceSegment(fenceDistance, fenceDistance, fenceDistance - postSpacing, fenceDistance));
      scene.add(createFenceSegment(fenceDistance, fenceDistance, fenceDistance, fenceDistance - postSpacing));
      
      // Canto Sudoeste
      scene.add(createFenceSegment(-fenceDistance, fenceDistance, -fenceDistance + postSpacing, fenceDistance));
      scene.add(createFenceSegment(-fenceDistance, fenceDistance, -fenceDistance, fenceDistance - postSpacing));
    }
    
    function createForests() {
      // Materiais das √°rvores
      const trunkMat = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
      const darkTrunkMat = new THREE.MeshLambertMaterial({ color: 0x3d2b1f });
      const leafMat1 = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      const leafMat2 = new THREE.MeshLambertMaterial({ color: 0x2d5a27 });
      const leafMat3 = new THREE.MeshLambertMaterial({ color: 0x3d8b3d });
      const leafMat4 = new THREE.MeshLambertMaterial({ color: 0x1a5a1a });
      
      const leafMats = [leafMat1, leafMat2, leafMat3, leafMat4];
      
      // Fun√ß√£o para criar uma √°rvore
      function createTree(x, z, scale = 1) {
        const treeGroup = new THREE.Group();
        
        const trunkH = (2.5 + Math.random() * 2) * scale;
        const trunkR = (0.25 + Math.random() * 0.12) * scale;
        const trunkGeo = new THREE.CylinderGeometry(trunkR * 0.6, trunkR, trunkH, 5);
        const trunk = new THREE.Mesh(trunkGeo, Math.random() > 0.5 ? trunkMat : darkTrunkMat);
        trunk.position.y = trunkH / 2;
        treeGroup.add(trunk);
        
        const leafMat = leafMats[Math.floor(Math.random() * leafMats.length)];
        const layers = 2 + Math.floor(Math.random() * 2);
        
        for (let i = 0; i < layers; i++) {
          const layerH = (2.5 + Math.random() * 1.5) * scale;
          const layerR = (1.8 + Math.random() * 1.2) * scale * (1 - i * 0.15);
          const layerGeo = new THREE.ConeGeometry(layerR, layerH, 6);
          const layer = new THREE.Mesh(layerGeo, leafMat);
          layer.position.y = trunkH + layerH * 0.25 + i * layerH * 0.45;
          treeGroup.add(layer);
        }
        
        treeGroup.position.set(x, 0, z);
        treeGroup.rotation.y = Math.random() * Math.PI * 2;
        return treeGroup;
      }
      
      // Fun√ß√£o para criar um arbusto
      function createBush(x, z, scale = 1) {
        const bushGroup = new THREE.Group();
        const leafMat = leafMats[Math.floor(Math.random() * leafMats.length)];
        
        const count = 2 + Math.floor(Math.random() * 3);
        for (let i = 0; i < count; i++) {
          const r = (0.5 + Math.random() * 0.4) * scale;
          const geo = new THREE.SphereGeometry(r, 5, 4);
          const bush = new THREE.Mesh(geo, leafMat);
          bush.position.set(
            (Math.random() - 0.5) * scale,
            r * 0.6,
            (Math.random() - 0.5) * scale
          );
          bushGroup.add(bush);
        }
        
        bushGroup.position.set(x, 0, z);
        return bushGroup;
      }
      
      // LIMITES - Floresta come√ßa BEM LONGE da cidade
      const tunnelClearance = 15; // Largura de exclus√£o para o t√∫nel (mais larga que a estrada)
      const forestStart = 48;  // Come√ßa bem ap√≥s a cidade
      const forestEnd = 95;    // Vai at√© perto das montanhas
      
      // Fun√ß√£o para verificar se est√° dentro da √°rea do t√∫nel
      function isInTunnelArea(x, z) {
        // T√∫neis est√£o nos 4 pontos cardeais
        // Norte: z muito negativo, x perto de 0
        // Sul: z muito positivo, x perto de 0
        // Leste: x muito positivo, z perto de 0
        // Oeste: x muito negativo, z perto de 0
        
        const inNorthTunnel = Math.abs(x) < tunnelClearance && z < -40;
        const inSouthTunnel = Math.abs(x) < tunnelClearance && z > 40;
        const inEastTunnel = Math.abs(z) < tunnelClearance && x > 40;
        const inWestTunnel = Math.abs(z) < tunnelClearance && x < -40;
        
        return inNorthTunnel || inSouthTunnel || inEastTunnel || inWestTunnel;
      }
      
      // Fun√ß√£o para verificar se est√° dentro da √°rea das montanhas
      function isInMountainArea(x, z) {
        const mountainRadius = 28; // Raio aproximado das montanhas
        
        // Montanhas do Norte (z ~ -100 a -130)
        if (z < -85) {
          // Montanhas laterais (fora do t√∫nel central)
          if (Math.abs(x) > 12 && Math.abs(x) < 50) return true;
          // Montanha central atr√°s
          if (Math.abs(x) < mountainRadius && z < -110) return true;
        }
        
        // Montanhas do Sul (z ~ +100 a +130)
        if (z > 85) {
          if (Math.abs(x) > 12 && Math.abs(x) < 50) return true;
          if (Math.abs(x) < mountainRadius && z > 110) return true;
        }
        
        // Montanhas do Leste (x ~ +100 a +130)
        if (x > 85) {
          if (Math.abs(z) > 12 && Math.abs(z) < 50) return true;
          if (Math.abs(z) < mountainRadius && x > 110) return true;
        }
        
        // Montanhas do Oeste (x ~ -100 a -130)
        if (x < -85) {
          if (Math.abs(z) > 12 && Math.abs(z) < 50) return true;
          if (Math.abs(z) < mountainRadius && x < -110) return true;
        }
        
        return false;
      }
      
      // Fun√ß√£o combinada para verificar se pode criar √°rvore
      function canPlaceTree(x, z) {
        return !isInTunnelArea(x, z) && !isInMountainArea(x, z);
      }
      
      // ===== FLORESTAS NOS 4 LADOS =====
      
      // NORTE (Z negativo)
      for (let i = 0; i < 100; i++) {
        const x = (Math.random() - 0.5) * 160;
        const z = -forestStart - Math.random() * (forestEnd - forestStart);
        
        if (!canPlaceTree(x, z)) continue; // Evita √°rea do t√∫nel e montanhas
        
        const scale = 0.6 + Math.random() * 0.6;
        scene.add(createTree(x, z, scale));
        
        if (Math.random() > 0.6) {
          const bx = x + 2;
          const bz = z + 2;
          if (canPlaceTree(bx, bz)) {
            scene.add(createBush(bx, bz, 0.7 + Math.random() * 0.4));
          }
        }
      }
      
      // SUL (Z positivo)
      for (let i = 0; i < 100; i++) {
        const x = (Math.random() - 0.5) * 160;
        const z = forestStart + Math.random() * (forestEnd - forestStart);
        
        if (!canPlaceTree(x, z)) continue;
        
        const scale = 0.6 + Math.random() * 0.6;
        scene.add(createTree(x, z, scale));
        
        if (Math.random() > 0.6) {
          const bx = x + 2;
          const bz = z - 2;
          if (canPlaceTree(bx, bz)) {
            scene.add(createBush(bx, bz, 0.7 + Math.random() * 0.4));
          }
        }
      }
      
      // LESTE (X positivo)
      for (let i = 0; i < 100; i++) {
        const x = forestStart + Math.random() * (forestEnd - forestStart);
        const z = (Math.random() - 0.5) * 160;
        
        if (!canPlaceTree(x, z)) continue;
        
        const scale = 0.6 + Math.random() * 0.6;
        scene.add(createTree(x, z, scale));
        
        if (Math.random() > 0.6) {
          const bx = x - 2;
          const bz = z + 2;
          if (canPlaceTree(bx, bz)) {
            scene.add(createBush(bx, bz, 0.7 + Math.random() * 0.4));
          }
        }
      }
      
      // OESTE (X negativo)
      for (let i = 0; i < 100; i++) {
        const x = -forestStart - Math.random() * (forestEnd - forestStart);
        const z = (Math.random() - 0.5) * 160;
        
        if (!canPlaceTree(x, z)) continue;
        
        const scale = 0.6 + Math.random() * 0.6;
        scene.add(createTree(x, z, scale));
        
        if (Math.random() > 0.6) {
          const bx = x + 2;
          const bz = z + 2;
          if (canPlaceTree(bx, bz)) {
            scene.add(createBush(bx, bz, 0.7 + Math.random() * 0.4));
          }
        }
      }
      
      // ===== CANTOS (diagonais) =====
      const corners = [
        { xSign: 1, zSign: 1 },
        { xSign: 1, zSign: -1 },
        { xSign: -1, zSign: 1 },
        { xSign: -1, zSign: -1 }
      ];
      
      corners.forEach(corner => {
        for (let i = 0; i < 50; i++) {
          const x = corner.xSign * (forestStart + Math.random() * 45);
          const z = corner.zSign * (forestStart + Math.random() * 45);
          
          if (!canPlaceTree(x, z)) continue; // Evita montanhas nos cantos
          
          const scale = 0.5 + Math.random() * 0.6;
          scene.add(createTree(x, z, scale));
          
          if (Math.random() > 0.5) {
            const bx = x + corner.xSign * 1.5;
            const bz = z + corner.zSign * 1.5;
            if (canPlaceTree(bx, bz)) {
              scene.add(createBush(bx, bz, 0.6 + Math.random() * 0.4));
            }
          }
        }
      });
    }

    // ==========================
    // PLAYER (v15)
    // ==========================

function createPlayer() {
  const group = new THREE.Group();

  // --- MATERIAIS ---
  const mSkin   = new THREE.MeshLambertMaterial({ color: 0xffccaa }); 
  const mShirt  = new THREE.MeshLambertMaterial({ color: 0xffffff }); 
  const mVest   = new THREE.MeshLambertMaterial({ color: 0xff5722 }); 
  const mJeans  = new THREE.MeshLambertMaterial({ color: 0x2196f3 }); 
  const mShoes  = new THREE.MeshLambertMaterial({ color: 0x3f51b5 }); 
  const mSole   = new THREE.MeshLambertMaterial({ color: 0x222222 }); 
  const mHat    = new THREE.MeshLambertMaterial({ color: 0xffc107 }); 
  const mHair   = new THREE.MeshLambertMaterial({ color: 0x3e2723 }); 
  const mEye    = new THREE.MeshBasicMaterial({ color: 0x222222 });
  const mWhite  = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const mBag    = new THREE.MeshLambertMaterial({ color: 0x4caf50 }); 

  // =====================
  // 1. QUADRIL (Centro de massa)
  // =====================
  const hips = new THREE.Group();
  hips.position.set(0, 0.81, 0); // Ajustado para p√©s tocarem o ch√£o
  group.add(hips);
  
  // Pelvis principal - AUMENTADA para garantir conex√£o com torso
  const hipsMesh = new THREE.Mesh(new THREE.BoxGeometry(0.26, 0.14, 0.145), mJeans);
  hipsMesh.position.y = 0.02; // Levemente elevada para sobrepor com waist
  hips.add(hipsMesh);
  
  // === SHORTS/EXTENS√ÉO DO QUADRIL - cobre a jun√ß√£o com as coxas ===
  // Parte esquerda do short (cobre o topo da coxa esquerda)
  const shortL = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.12, 0.13), mJeans);
  shortL.position.set(-0.08, -0.08, 0);
  hips.add(shortL);
  
  // Parte direita do short (cobre o topo da coxa direita)
  const shortR = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.12, 0.13), mJeans);
  shortR.position.set(0.08, -0.08, 0);
  hips.add(shortR);
  
  // Parte central do short (conecta os dois lados)
  const shortCenter = new THREE.Mesh(new THREE.BoxGeometry(0.10, 0.10, 0.12), mJeans);
  shortCenter.position.set(0, -0.06, 0);
  hips.add(shortCenter);
  
  // Cinto com fivela (posicionado no topo do quadril)
  const belt = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.04, 0.155), new THREE.MeshLambertMaterial({ color: 0x4a3728 }));
  belt.position.y = 0.08;
  hips.add(belt);
  const buckle = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.035, 0.02), new THREE.MeshLambertMaterial({ color: 0xc0c0c0 }));
  buckle.position.set(0, 0.08, 0.085);
  hips.add(buckle);

  // =====================
  // 2. PERNAS - Design de t√™nis melhorado
  // =====================
  
  // --- PERNA ESQUERDA ---
  const thighL = new THREE.Group();
  thighL.position.set(-0.08, -0.10, 0); // Posi√ß√£o ajustada para ficar sob o short
  hips.add(thighL);
  
  // Transi√ß√£o quadril-coxa (GRANDE para sobrepor com short)
  const hipTransL = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.14, 0.13), mJeans);
  hipTransL.position.y = 0.04;
  thighL.add(hipTransL);
  
  // Coxa
  const thighLMesh = new THREE.Mesh(new THREE.BoxGeometry(0.11, 0.24, 0.11), mJeans);
  thighLMesh.position.y = -0.08;
  thighL.add(thighLMesh);

  // Joelho/Canela
  const kneeL = new THREE.Group();
  kneeL.position.set(0, -0.24, 0); // Subiu para conectar
  thighL.add(kneeL);
  
  // Joelho - preenchimento
  const kneeCapL = new THREE.Mesh(new THREE.BoxGeometry(0.11, 0.06, 0.11), mJeans);
  kneeCapL.position.y = 0;
  kneeL.add(kneeCapL);
  
  // Canela (mais longa, com overlap no tornozelo)
  const shinLMesh = new THREE.Mesh(new THREE.BoxGeometry(0.10, 0.32, 0.10), mJeans);
  shinLMesh.position.y = -0.15;
  kneeL.add(shinLMesh);

  // Tornozelo/P√© - Design de t√™nis
  const ankleL = new THREE.Group();
  ankleL.position.set(0, -0.31, 0);
  kneeL.add(ankleL);

  // MEIA BRANCA - preenche entre cal√ßa e t√™nis (com polygonOffset para evitar z-fighting)
  const mSock = new THREE.MeshLambertMaterial({ 
    color: 0xffffff,
    polygonOffset: true,
    polygonOffsetFactor: 1,
    polygonOffsetUnits: 1
  });
  const sockL = new THREE.Mesh(new THREE.BoxGeometry(0.098, 0.13, 0.098), mSock);
  sockL.position.set(0, 0.0, 0);
  ankleL.add(sockL);

  const footL = new THREE.Group();
  footL.position.set(0, -0.04, 0.02); // Subiu mais para conectar com meia
  ankleL.add(footL);
  
  // T√™nis - Cano (tornozelo) - conecta com meia
  const shoeAnkleL = new THREE.Mesh(new THREE.BoxGeometry(0.108, 0.08, 0.108), mShoes);
  shoeAnkleL.position.set(0, 0.06, -0.01); // Cano mais alto
  footL.add(shoeAnkleL);
  
  // T√™nis - Corpo principal
  const shoeBodyL = new THREE.Mesh(new THREE.BoxGeometry(0.10, 0.07, 0.16), mShoes);
  shoeBodyL.position.set(0, 0.01, 0.01);
  footL.add(shoeBodyL);
  // T√™nis - Bico arredondado
  const shoeToeL = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.06, 0.05), mShoes);
  shoeToeL.position.set(0, 0.005, 0.10);
  footL.add(shoeToeL);
  // T√™nis - Sola
  const shoeSoleL = new THREE.Mesh(new THREE.BoxGeometry(0.11, 0.025, 0.18), mSole);
  shoeSoleL.position.set(0, -0.03, 0.02);
  footL.add(shoeSoleL);

  // --- PERNA DIREITA ---
  const thighR = new THREE.Group();
  thighR.position.set(0.08, -0.10, 0); // Posi√ß√£o ajustada para ficar sob o short
  hips.add(thighR);
  
  // Transi√ß√£o quadril-coxa (GRANDE para sobrepor com short)
  const hipTransR = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.14, 0.13), mJeans);
  hipTransR.position.y = 0.04;
  thighR.add(hipTransR);
  
  // Coxa
  const thighRMesh = new THREE.Mesh(new THREE.BoxGeometry(0.11, 0.24, 0.11), mJeans);
  thighRMesh.position.y = -0.08;
  thighR.add(thighRMesh);

  const kneeR = new THREE.Group();
  kneeR.position.set(0, -0.24, 0);
  thighR.add(kneeR);
  
  // Joelho
  const kneeCapR = new THREE.Mesh(new THREE.BoxGeometry(0.11, 0.06, 0.11), mJeans);
  kneeCapR.position.y = 0;
  kneeR.add(kneeCapR);
  
  // Canela (mais longa, com overlap no tornozelo)
  const shinRMesh = new THREE.Mesh(new THREE.BoxGeometry(0.10, 0.32, 0.10), mJeans);
  shinRMesh.position.y = -0.15;
  kneeR.add(shinRMesh);

  const ankleR = new THREE.Group();
  ankleR.position.set(0, -0.31, 0);
  kneeR.add(ankleR);

  // MEIA BRANCA direita - preenche entre cal√ßa e t√™nis
  const sockR = new THREE.Mesh(new THREE.BoxGeometry(0.098, 0.13, 0.098), mSock);
  sockR.position.set(0, 0.0, 0);
  ankleR.add(sockR);

  const footR = new THREE.Group();
  footR.position.set(0, -0.04, 0.02); // Subiu mais para conectar com meia
  ankleR.add(footR);
  
  // T√™nis - Cano (tornozelo) - conecta com meia
  const shoeAnkleR = new THREE.Mesh(new THREE.BoxGeometry(0.108, 0.08, 0.108), mShoes);
  shoeAnkleR.position.set(0, 0.06, -0.01); // Cano mais alto
  footR.add(shoeAnkleR);
  
  // T√™nis - Corpo principal
  const shoeBodyR = new THREE.Mesh(new THREE.BoxGeometry(0.10, 0.07, 0.16), mShoes);
  shoeBodyR.position.set(0, 0.01, 0.01);
  footR.add(shoeBodyR);
  const shoeToeR = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.06, 0.05), mShoes);
  shoeToeR.position.set(0, 0.005, 0.10);
  footR.add(shoeToeR);
  const shoeSoleR = new THREE.Mesh(new THREE.BoxGeometry(0.11, 0.025, 0.18), mSole);
  shoeSoleR.position.set(0, -0.03, 0.02);
  footR.add(shoeSoleR);

  // =====================
  // 3. TORSO
  // =====================
  const torso = new THREE.Group();
  torso.position.set(0, 0.10, 0); // ACIMA do cinto (cinto est√° em Y=0.08)
  hips.add(torso);
  
  // === MATERIAIS COM POLYGON OFFSET PARA EVITAR Z-FIGHTING ===
  // Camisa fica "atr√°s" do colete
  const mShirtBody = new THREE.MeshLambertMaterial({ 
    color: 0xffffff,
    polygonOffset: true,
    polygonOffsetFactor: 1,
    polygonOffsetUnits: 1
  });
  
  // Cintura - MENOR que o cinto para n√£o atravessar (cinto = 0.28 x 0.155)
  const waist = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.10, 0.12), mShirtBody);
  waist.position.set(0, 0.0, 0); // Na base do torso, acima do cinto
  torso.add(waist);
  
  // Barriga (camisa) - expande gradualmente
  const belly = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.12, 0.13), mShirtBody);
  belly.position.set(0, 0.10, 0);
  torso.add(belly);
  
  // Peito (colete) - fica por cima
  const chest = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.18, 0.15), mVest);
  chest.position.set(0, 0.22, 0.01);
  torso.add(chest);
  
  // Detalhes do colete - bolsos
  const pocketVestL = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.05, 0.02), new THREE.MeshLambertMaterial({ color: 0xe64a19 }));
  pocketVestL.position.set(-0.08, 0.20, 0.09);
  torso.add(pocketVestL);
  const pocketVestR = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.05, 0.02), new THREE.MeshLambertMaterial({ color: 0xe64a19 }));
  pocketVestR.position.set(0.08, 0.20, 0.09);
  torso.add(pocketVestR);
  
  // Gola
  const collar = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.04, 0.08), mShirt);
  collar.position.set(0, 0.34, 0.04);
  torso.add(collar);

  // =====================
  // 4. MOCHILA
  // =====================
  const backpack = new THREE.Mesh(new THREE.BoxGeometry(0.20, 0.24, 0.10), mBag);
  backpack.position.set(0, 0.20, -0.12);
  torso.add(backpack);
  
  // Bolso da mochila
  const pocketMat = new THREE.MeshLambertMaterial({ 
    color: 0x388e3c,
    polygonOffset: true,
    polygonOffsetFactor: -1,
    polygonOffsetUnits: -1
  });
  const pocket = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.08, 0.025), pocketMat);
  pocket.position.set(0, 0.14, -0.18);
  torso.add(pocket);
  
  // =====================
  // AL√áAS DA MOCHILA - REALISTAS
  // =====================
  const mStrap = new THREE.MeshLambertMaterial({ 
    color: 0x4caf50,
    polygonOffset: true,
    polygonOffsetFactor: -2,
    polygonOffsetUnits: -2
  });
  
  // === AL√áA ESQUERDA ===
  // Parte 1: Sai do topo da mochila (traseira)
  const strapLBack = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.08, 0.03), mStrap);
  strapLBack.position.set(-0.06, 0.30, -0.09);
  torso.add(strapLBack);
  
  // Parte 2: Passa por cima do ombro
  const strapLShoulder = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, 0.12), mStrap);
  strapLShoulder.position.set(-0.08, 0.33, -0.01);
  torso.add(strapLShoulder);
  
  // Parte 3: Desce pela frente - superior
  const strapLFrontUpper = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.10, 0.03), mStrap);
  strapLFrontUpper.position.set(-0.10, 0.27, 0.07);
  torso.add(strapLFrontUpper);
  
  // Parte 4: Desce pela frente - inferior
  const strapLFrontLower = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.14, 0.03), mStrap);
  strapLFrontLower.position.set(-0.10, 0.13, 0.07);
  torso.add(strapLFrontLower);
  
  // === AL√áA DIREITA ===
  // Parte 1: Sai do topo da mochila (traseira)
  const strapRBack = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.08, 0.03), mStrap);
  strapRBack.position.set(0.06, 0.30, -0.09);
  torso.add(strapRBack);
  
  // Parte 2: Passa por cima do ombro
  const strapRShoulder = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, 0.12), mStrap);
  strapRShoulder.position.set(0.08, 0.33, -0.01);
  torso.add(strapRShoulder);
  
  // Parte 3: Desce pela frente - superior
  const strapRFrontUpper = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.10, 0.03), mStrap);
  strapRFrontUpper.position.set(0.10, 0.27, 0.07);
  torso.add(strapRFrontUpper);
  
  // Parte 4: Desce pela frente - inferior
  const strapRFrontLower = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.14, 0.03), mStrap);
  strapRFrontLower.position.set(0.10, 0.13, 0.07);
  torso.add(strapRFrontLower);
  
  // Refer√™ncias para anima√ß√£o (usar a parte do ombro)
  const strapL = strapLShoulder;
  const strapR = strapRShoulder;

  // =====================
  // 5. BRA√áOS - CORRIGIDOS (antebra√ßos para frente)
  // =====================

  // --- BRA√áO ESQUERDO ---
  const shoulderL = new THREE.Group();
  shoulderL.position.set(-0.17, 0.28, 0); // Ajustado para nova posi√ß√£o do torso
  torso.add(shoulderL);
  
  // Manga - camisa por baixo (renderiza primeiro)
  const mSleeve = new THREE.MeshLambertMaterial({ 
    color: 0xffffff,
    polygonOffset: true,
    polygonOffsetFactor: 1,
    polygonOffsetUnits: 1
  });
  const sleeveL = new THREE.Mesh(new THREE.BoxGeometry(0.085, 0.08, 0.085), mSleeve);
  sleeveL.position.y = -0.04;
  shoulderL.add(sleeveL);
  
  // Ombro do colete - por cima da manga
  const shoulderCapL = new THREE.Mesh(new THREE.BoxGeometry(0.075, 0.065, 0.075), mVest);
  shoulderCapL.position.set(-0.01, 0.0, 0.0);
  shoulderL.add(shoulderCapL);
  
  // Bra√ßo superior - conectado
  const upperArmL = new THREE.Mesh(new THREE.BoxGeometry(0.075, 0.14, 0.075), mSkin);
  upperArmL.position.y = -0.12;
  shoulderL.add(upperArmL);

  // Cotovelo
  const elbowL = new THREE.Group();
  elbowL.position.set(0, -0.19, 0);
  shoulderL.add(elbowL);
  
  // Cotovelo - box para preencher
  const elbowCapL = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.05, 0.07), mSkin);
  elbowL.add(elbowCapL);
  
  // Antebra√ßo - alinhado com o bra√ßo (sem deslocamento Z)
  const forearmL = new THREE.Mesh(new THREE.BoxGeometry(0.065, 0.14, 0.065), mSkin);
  forearmL.position.set(0, -0.09, 0);
  elbowL.add(forearmL);

  // M√£o
  const wristL = new THREE.Group();
  wristL.position.set(0, -0.16, 0);
  elbowL.add(wristL);
  
  // M√£o com dedos sugeridos
  const handL = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.06, 0.04), mSkin);
  handL.position.set(0, -0.02, 0.01);
  wristL.add(handL);
  const fingersL = new THREE.Mesh(new THREE.BoxGeometry(0.045, 0.04, 0.03), mSkin);
  fingersL.position.set(0, -0.05, 0.01);
  wristL.add(fingersL);

  // --- BRA√áO DIREITO ---
  const shoulderR = new THREE.Group();
  shoulderR.position.set(0.17, 0.28, 0); // Ajustado para nova posi√ß√£o do torso
  torso.add(shoulderR);
  
  // Manga direita - camisa por baixo
  const sleeveR = new THREE.Mesh(new THREE.BoxGeometry(0.085, 0.08, 0.085), mSleeve);
  sleeveR.position.y = -0.04;
  shoulderR.add(sleeveR);
  
  // Ombro do colete direito - por cima da manga
  const shoulderCapR = new THREE.Mesh(new THREE.BoxGeometry(0.075, 0.065, 0.075), mVest);
  shoulderCapR.position.set(0.01, 0.0, 0.0);
  shoulderR.add(shoulderCapR);
  
  const upperArmR = new THREE.Mesh(new THREE.BoxGeometry(0.075, 0.14, 0.075), mSkin);
  upperArmR.position.y = -0.12;
  shoulderR.add(upperArmR);

  const elbowR = new THREE.Group();
  elbowR.position.set(0, -0.19, 0);
  shoulderR.add(elbowR);
  
  const elbowCapR = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.05, 0.07), mSkin);
  elbowR.add(elbowCapR);
  
  // Antebra√ßo direito - alinhado com o bra√ßo (sem deslocamento Z)
  const forearmR = new THREE.Mesh(new THREE.BoxGeometry(0.065, 0.14, 0.065), mSkin);
  forearmR.position.set(0, -0.09, 0);
  elbowR.add(forearmR);

  const wristR = new THREE.Group();
  wristR.position.set(0, -0.16, 0);
  elbowR.add(wristR);
  
  const handR = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.06, 0.04), mSkin);
  handR.position.set(0, -0.02, 0.01);
  wristR.add(handR);
  const fingersR = new THREE.Mesh(new THREE.BoxGeometry(0.045, 0.04, 0.03), mSkin);
  fingersR.position.set(0, -0.05, 0.01);
  wristR.add(fingersR);

  // =====================
  // 6. CABE√áA - Pupilas fixas dentro do olho
  // =====================
  const headPivot = new THREE.Group();
  headPivot.position.set(0, 0.35, 0); // Ajustado para nova posi√ß√£o do torso
  torso.add(headPivot);
  
  // Pesco√ßo
  const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 0.07, 8), mSkin);
  neck.position.y = 0.035;
  headPivot.add(neck);
  
  // Cabe√ßa
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.20, 0.22, 0.20), mSkin);
  head.position.y = 0.18;
  head.name = "head";
  headPivot.add(head);
  
  // Orelhas - mais detalhadas
  const earL = new THREE.Mesh(new THREE.BoxGeometry(0.025, 0.05, 0.025), mSkin);
  earL.position.set(-0.11, 0.16, 0);
  headPivot.add(earL);
  const earLobeL = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 0.02), mSkin);
  earLobeL.position.set(-0.11, 0.13, 0);
  headPivot.add(earLobeL);
  
  const earR = new THREE.Mesh(new THREE.BoxGeometry(0.025, 0.05, 0.025), mSkin);
  earR.position.set(0.11, 0.16, 0);
  headPivot.add(earR);
  const earLobeR = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 0.02), mSkin);
  earLobeR.position.set(0.11, 0.13, 0);
  headPivot.add(earLobeR);
  
  // Cabelo
  const hair = new THREE.Mesh(new THREE.BoxGeometry(0.21, 0.04, 0.21), mHair);
  hair.position.y = 0.30;
  headPivot.add(hair);
  const hairBack = new THREE.Mesh(new THREE.BoxGeometry(0.21, 0.12, 0.03), mHair);
  hairBack.position.set(0, 0.24, -0.10);
  headPivot.add(hairBack);
  // Cabelo laterais - mais completo
  const hairSideL = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.12, 0.18), mHair);
  hairSideL.position.set(-0.10, 0.24, -0.02);
  headPivot.add(hairSideL);
  const hairSideR = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.12, 0.18), mHair);
  hairSideR.position.set(0.10, 0.24, -0.02);
  headPivot.add(hairSideR);
  // Cabelo frontal (franja sob o bon√©)
  const hairFront = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.03, 0.03), mHair);
  hairFront.position.set(0, 0.27, 0.08);
  headPivot.add(hairFront);
  
  // Bon√©
  const cap = new THREE.Mesh(new THREE.BoxGeometry(0.23, 0.04, 0.23), mHat);
  cap.position.y = 0.32;
  headPivot.add(cap);
  const brim = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.015, 0.10), mHat);
  brim.position.set(0, 0.31, 0.13);
  brim.rotation.x = -0.12;
  headPivot.add(brim);
  // Bot√£o do bon√©
  const capButton = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.01, 8), mHat);
  capButton.position.y = 0.345;
  headPivot.add(capButton);
  
  // OLHOS - Sistema melhorado (pupilas como filhas do branco do olho)
  // Olho esquerdo - container
  const eyeContainerL = new THREE.Group();
  eyeContainerL.position.set(-0.05, 0.20, 0.10);
  headPivot.add(eyeContainerL);
  
  // Branco do olho
  const eyeWhiteL = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.035, 0.01), mWhite);
  eyeContainerL.add(eyeWhiteL);
  
  // Pupila - FILHA do branco (n√£o sai do olho)
  const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.018, 0.022, 0.008), mEye);
  eyeL.position.z = 0.005; // Ligeiramente na frente
  eyeContainerL.add(eyeL);
  
  // Olho direito - container
  const eyeContainerR = new THREE.Group();
  eyeContainerR.position.set(0.05, 0.20, 0.10);
  headPivot.add(eyeContainerR);
  
  const eyeWhiteR = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.035, 0.01), mWhite);
  eyeContainerR.add(eyeWhiteR);
  
  const eyeR = new THREE.Mesh(new THREE.BoxGeometry(0.018, 0.022, 0.008), mEye);
  eyeR.position.z = 0.005;
  eyeContainerR.add(eyeR);
  
  // Sobrancelhas
  const browL = new THREE.Mesh(new THREE.BoxGeometry(0.035, 0.01, 0.012), mHair);
  browL.position.set(-0.05, 0.235, 0.10);
  headPivot.add(browL);
  const browR = new THREE.Mesh(new THREE.BoxGeometry(0.035, 0.01, 0.012), mHair);
  browR.position.set(0.05, 0.235, 0.10);
  headPivot.add(browR);
  
  // Nariz - mais definido
  const nose = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.035, 0.025), mSkin);
  nose.position.set(0, 0.155, 0.105);
  headPivot.add(nose);
  const noseTip = new THREE.Mesh(new THREE.BoxGeometry(0.025, 0.015, 0.015), mSkin);
  noseTip.position.set(0, 0.14, 0.115);
  headPivot.add(noseTip);
  
  // Boca
  const mouth = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.012, 0.008), new THREE.MeshBasicMaterial({ color: 0xcc9999 }));
  mouth.position.set(0, 0.115, 0.10);
  headPivot.add(mouth);

  // =====================
  // 7. ARMA - LAN√áA-SACOLAS DETALHADO
  // =====================
  const gun = new THREE.Group();
  
  // Materiais
  const weaponColor = WEAPON_DATA[currentWeapon].color;
  const mWeaponMain = new THREE.MeshPhongMaterial({ color: weaponColor, shininess: 60 });
  const mWeaponDark = new THREE.MeshPhongMaterial({ color: 0x222222, shininess: 40 });
  const mWeaponMetal = new THREE.MeshPhongMaterial({ color: 0x555555, shininess: 80 });
  const mWeaponAccent = new THREE.MeshPhongMaterial({ color: 0x111111, shininess: 30 });
  const mWeaponGlow = new THREE.MeshBasicMaterial({ color: weaponColor });
  
  // === CORPO PRINCIPAL ===
  // Base do corpo (mais elaborada)
  const gBody = new THREE.Mesh(
    new THREE.BoxGeometry(0.05, 0.075, 0.20), 
    mWeaponMain
  );
  gBody.name = "gun_body";
  gun.add(gBody);
  
  // Detalhe superior do corpo
  const gBodyTop = new THREE.Mesh(
    new THREE.BoxGeometry(0.04, 0.02, 0.16),
    mWeaponDark
  );
  gBodyTop.position.set(0, 0.045, 0);
  gun.add(gBodyTop);
  
  // Trilho superior (estilo tactical)
  const gRail = new THREE.Mesh(
    new THREE.BoxGeometry(0.025, 0.012, 0.12),
    mWeaponMetal
  );
  gRail.position.set(0, 0.058, 0.02);
  gun.add(gRail);
  
  // Ranhuras do trilho
  for (let i = 0; i < 5; i++) {
    const groove = new THREE.Mesh(
      new THREE.BoxGeometry(0.028, 0.004, 0.008),
      mWeaponAccent
    );
    groove.position.set(0, 0.066, -0.03 + i * 0.025);
    gun.add(groove);
  }
  
  // === CANO / BOCAL ===
  // Cano principal (cilindro maior)
  const gBarrelOuter = new THREE.Mesh(
    new THREE.CylinderGeometry(0.025, 0.028, 0.14, 12),
    mWeaponMetal
  );
  gBarrelOuter.rotation.x = Math.PI / 2;
  gBarrelOuter.position.z = 0.16;
  gBarrelOuter.name = "gun_barrel";
  gun.add(gBarrelOuter);
  
  // Cano interno (onde sai a sacola)
  const gBarrelInner = new THREE.Mesh(
    new THREE.CylinderGeometry(0.018, 0.018, 0.15, 10),
    mWeaponDark
  );
  gBarrelInner.rotation.x = Math.PI / 2;
  gBarrelInner.position.z = 0.165;
  gun.add(gBarrelInner);
  
  // Bocal de sa√≠da (onde a sacola sai)
  const gMuzzle = new THREE.Mesh(
    new THREE.CylinderGeometry(0.022, 0.018, 0.03, 10),
    mWeaponAccent
  );
  gMuzzle.rotation.x = Math.PI / 2;
  gMuzzle.position.z = 0.24;
  gMuzzle.name = "gun_muzzle"; // Ponta da arma
  gun.add(gMuzzle);
  
  // Anel decorativo no cano
  const gBarrelRing1 = new THREE.Mesh(
    new THREE.TorusGeometry(0.028, 0.004, 6, 12),
    mWeaponMetal
  );
  gBarrelRing1.rotation.x = Math.PI / 2;
  gBarrelRing1.position.z = 0.12;
  gun.add(gBarrelRing1);
  
  const gBarrelRing2 = new THREE.Mesh(
    new THREE.TorusGeometry(0.026, 0.003, 6, 12),
    mWeaponMetal
  );
  gBarrelRing2.rotation.x = Math.PI / 2;
  gBarrelRing2.position.z = 0.20;
  gun.add(gBarrelRing2);
  
  // === CABO / EMPUNHADURA ===
  // Cabo principal
  const gHandle = new THREE.Mesh(
    new THREE.BoxGeometry(0.035, 0.075, 0.045),
    mWeaponDark
  );
  gHandle.position.set(0, -0.06, -0.04);
  gHandle.rotation.x = 0.15;
  gun.add(gHandle);
  
  // Grip texturizado (linhas no cabo)
  for (let i = 0; i < 4; i++) {
    const gripLine = new THREE.Mesh(
      new THREE.BoxGeometry(0.038, 0.005, 0.048),
      mWeaponAccent
    );
    gripLine.position.set(0, -0.04 - i * 0.015, -0.04);
    gripLine.rotation.x = 0.15;
    gun.add(gripLine);
  }
  
  // Base do cabo (ergon√¥mico)
  const gHandleBase = new THREE.Mesh(
    new THREE.BoxGeometry(0.04, 0.02, 0.05),
    mWeaponDark
  );
  gHandleBase.position.set(0, -0.10, -0.035);
  gHandleBase.rotation.x = 0.2;
  gun.add(gHandleBase);
  
  // === GATILHO ===
  // Guarda do gatilho
  const gTriggerGuard = new THREE.Mesh(
    new THREE.TorusGeometry(0.018, 0.004, 4, 8, Math.PI),
    mWeaponMetal
  );
  gTriggerGuard.rotation.z = Math.PI;
  gTriggerGuard.rotation.y = Math.PI / 2;
  gTriggerGuard.position.set(0, -0.035, -0.02);
  gun.add(gTriggerGuard);
  
  // Gatilho
  const gTrigger = new THREE.Mesh(
    new THREE.BoxGeometry(0.008, 0.025, 0.012),
    mWeaponMetal
  );
  gTrigger.position.set(0, -0.028, -0.015);
  gTrigger.rotation.x = 0.3;
  gun.add(gTrigger);
  
  // === DETALHES TRASEIROS ===
  // Bloco traseiro
  const gRear = new THREE.Mesh(
    new THREE.BoxGeometry(0.045, 0.06, 0.04),
    mWeaponMain
  );
  gRear.position.set(0, 0.005, -0.10);
  gun.add(gRear);
  
  // Mira traseira
  const gRearSight = new THREE.Mesh(
    new THREE.BoxGeometry(0.035, 0.015, 0.008),
    mWeaponAccent
  );
  gRearSight.position.set(0, 0.065, -0.08);
  gun.add(gRearSight);
  
  // Entalhes da mira traseira
  const gSightNotchL = new THREE.Mesh(
    new THREE.BoxGeometry(0.004, 0.018, 0.01),
    mWeaponAccent
  );
  gSightNotchL.position.set(-0.012, 0.065, -0.08);
  gun.add(gSightNotchL);
  
  const gSightNotchR = gSightNotchL.clone();
  gSightNotchR.position.x = 0.012;
  gun.add(gSightNotchR);
  
  // === MIRA FRONTAL ===
  const gFrontSight = new THREE.Mesh(
    new THREE.BoxGeometry(0.008, 0.02, 0.008),
    mWeaponAccent
  );
  gFrontSight.position.set(0, 0.06, 0.08);
  gun.add(gFrontSight);
  
  // Ponto luminoso na mira (cor da arma)
  const gSightDot = new THREE.Mesh(
    new THREE.SphereGeometry(0.004, 6, 6),
    mWeaponGlow
  );
  gSightDot.position.set(0, 0.072, 0.08);
  gun.add(gSightDot);
  
  // === DETALHES LATERAIS ===
  // Painel lateral esquerdo
  const gPanelL = new THREE.Mesh(
    new THREE.BoxGeometry(0.008, 0.04, 0.10),
    mWeaponDark
  );
  gPanelL.position.set(-0.028, 0.01, 0);
  gun.add(gPanelL);
  
  // Painel lateral direito
  const gPanelR = gPanelL.clone();
  gPanelR.position.x = 0.028;
  gun.add(gPanelR);
  
  // Bot√£o de eje√ß√£o (lado direito)
  const gEjectBtn = new THREE.Mesh(
    new THREE.CylinderGeometry(0.006, 0.006, 0.005, 8),
    mWeaponMetal
  );
  gEjectBtn.rotation.z = Math.PI / 2;
  gEjectBtn.position.set(0.032, 0.02, 0.02);
  gun.add(gEjectBtn);
  
  // Indicador de muni√ß√£o (LED)
  const gAmmoLED = new THREE.Mesh(
    new THREE.BoxGeometry(0.015, 0.008, 0.003),
    mWeaponGlow
  );
  gAmmoLED.position.set(0.028, -0.01, 0.04);
  gun.add(gAmmoLED);
  
  // Posi√ß√£o final da arma na m√£o
  gun.position.set(0, -0.04, 0.08);
  gun.rotation.x = -0.1;
  wristR.add(gun);

  // =====================
  // POSI√á√ÉO INICIAL
  // =====================
  group.position.set(0, 0, 4);
  scene.add(group);

  // =====================
  // RIGGING
  // =====================
  player = {
    object: group,
    velocity: new THREE.Vector3(),
    yaw: 0, 
    speed: 5, 
    shootRecoil: 0, 
    shootPose: 0, 
    verticalVelocity: 0, 
    isGrounded: true, 
    baseY: 0,
    isKnockedDown: false,
    recoverTimer: 0,
    rig: {
      hips, 
      torso, 
      headPivot, 
      head,
      
      shoulderL, elbowL, wristL,
      shoulderR, elbowR, wristR,
      handLPalm: wristL, handRPalm: wristR,

      thighL, kneeL, ankleL, footL,
      thighR, kneeR, ankleR, footR,

      backpackRoot: backpack, gun, bagSocketL: wristL,
      flap: new THREE.Object3D(), strapL, strapR,
      
      // Olhos - agora s√£o as pupilas dentro do container
      eyeL, eyeR, 
      pupilL: eyeL, pupilR: eyeR
    }
  };
  
  player.object.userData.gun = gun;
  gunBaseLocalPos = gun.position.clone();
}

    // ==========================
    // BINS
    // ==========================

function createBins() {
  bins.forEach(b => scene.remove(b.mesh));
  bins = [];

  // --- POSI√á√ÉO ENTRE O JARDIM E A CAL√áADA ---
  // Coloca as lixeiras na borda do jardim, viradas para a cal√ßada/rua
  
  const blockCenterX = 8.0;  // Centro do primeiro quarteir√£o √† direita
  const edgeZ = 3.6;         // Na borda entre jardim e cal√ßada
  
  const startX = blockCenterX - 2.2; // Centraliza as 4 lixeiras
  const spacing = 1.3; // Espa√ßo entre lixeiras (um pouco menor pois s√£o mais estreitas)

  // Rota√ß√£o: Viradas para o jardim/centro
  const rotation = Math.PI; 

  BIN_DEFINITIONS.forEach((def, i) => {
    const mesh = createBinMesh(def.color);
    
    // Posiciona na borda do jardim
    mesh.position.set(startX + i * spacing, 0, edgeZ);
    mesh.rotation.y = rotation;
    
    mesh.userData = { material: def.material, name: def.name, color: def.color };
    mesh.name = `bin_${def.name}`;
    
    scene.add(mesh);
    bins.push({ mesh, def, glowPhase: Math.random() * Math.PI * 2 });
    
    // Colis√£o
    addCylCollider(mesh.position.x, mesh.position.z, 0.55);
  });
}

    function createBinMesh(color) {
      const group = new THREE.Group();
      
      // Material principal com melhor qualidade
      const mainMat = new THREE.MeshPhongMaterial({ 
        color, 
        shininess: 30,
        flatShading: false 
      });
      const darkMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a, shininess: 20 });
      const whiteMat = new THREE.MeshPhongMaterial({ color: 0xffffff, shininess: 40 });
      
      // Cor mais escura para a tampa
      const darkerColor = new THREE.Color(color).multiplyScalar(0.8);
      const lidMat = new THREE.MeshPhongMaterial({ color: darkerColor, shininess: 35 });

      // Corpo principal - com cantos levemente arredondados (mais segmentos)
      const bodyGeo = new THREE.BoxGeometry(0.88, 1.25, 0.72, 2, 2, 2);
      const body = new THREE.Mesh(bodyGeo, mainMat);
      body.position.y = 0.68;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Refor√ßo superior do corpo (borda)
      const rimGeo = new THREE.BoxGeometry(0.92, 0.06, 0.76);
      const rim = new THREE.Mesh(rimGeo, mainMat);
      rim.position.y = 1.33;
      group.add(rim);
      
      // Base mais larga
      const baseGeo = new THREE.BoxGeometry(0.92, 0.08, 0.76);
      const base = new THREE.Mesh(baseGeo, mainMat);
      base.position.y = 0.04;
      group.add(base);
      
      // === TAMPA LIMPA E REFINADA ===
      // Tampa principal
      const lidGeo = new THREE.BoxGeometry(0.90, 0.14, 0.74, 2, 1, 2);
      const lid = new THREE.Mesh(lidGeo, lidMat);
      lid.position.set(0, 1.43, 0);
      lid.castShadow = true;
      group.add(lid);
      
      // Topo da tampa (levemente elevado no centro)
      const lidTopGeo = new THREE.BoxGeometry(0.82, 0.04, 0.66);
      const lidTop = new THREE.Mesh(lidTopGeo, lidMat);
      lidTop.position.set(0, 1.52, 0);
      group.add(lidTop);
      
      // Al√ßa da tampa - design limpo
      const handleGeo = new THREE.BoxGeometry(0.28, 0.05, 0.10);
      const handleMat = new THREE.MeshPhongMaterial({ color: darkerColor.clone().multiplyScalar(0.9), shininess: 25 });
      const handle = new THREE.Mesh(handleGeo, handleMat);
      handle.position.set(0, 1.56, 0);
      group.add(handle);
      
      // Fenda da al√ßa (para pegar)
      const slotGeo = new THREE.BoxGeometry(0.18, 0.06, 0.05);
      const slot = new THREE.Mesh(slotGeo, darkMat);
      slot.position.set(0, 1.55, 0);
      group.add(slot);
      
      // === RODINHAS COM MAIS QUALIDADE ===
      const wheelGeo = new THREE.CylinderGeometry(0.09, 0.09, 0.05, 16);
      const wheelL = new THREE.Mesh(wheelGeo, darkMat);
      wheelL.rotation.z = Math.PI / 2;
      wheelL.position.set(-0.40, 0.09, -0.28);
      wheelL.castShadow = true;
      group.add(wheelL);
      
      const wheelR = new THREE.Mesh(wheelGeo, darkMat);
      wheelR.rotation.z = Math.PI / 2;
      wheelR.position.set(0.40, 0.09, -0.28);
      wheelR.castShadow = true;
      group.add(wheelR);
      
      // Aro das rodinhas
      const hubGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.06, 12);
      const hubL = new THREE.Mesh(hubGeo, new THREE.MeshPhongMaterial({ color: 0x444444 }));
      hubL.rotation.z = Math.PI / 2;
      hubL.position.set(-0.40, 0.09, -0.28);
      group.add(hubL);
      
      const hubR = new THREE.Mesh(hubGeo, new THREE.MeshPhongMaterial({ color: 0x444444 }));
      hubR.rotation.z = Math.PI / 2;
      hubR.position.set(0.40, 0.09, -0.28);
      group.add(hubR);
      
      // P√©s frontais
      const footGeo = new THREE.CylinderGeometry(0.04, 0.05, 0.04, 8);
      const footL = new THREE.Mesh(footGeo, darkMat);
      footL.position.set(-0.32, 0.02, 0.26);
      group.add(footL);
      
      const footR = new THREE.Mesh(footGeo, darkMat);
      footR.position.set(0.32, 0.02, 0.26);
      group.add(footR);
      
      // === S√çMBOLO DE RECICLAGEM REFINADO ===
      const symbolGroup = new THREE.Group();
      
      // Criar seta com geometria mais suave
      function createArrow() {
        const arrowGrp = new THREE.Group();
        
        // Corpo da seta (ret√¢ngulo arredondado)
        const bodyGeo = new THREE.BoxGeometry(0.055, 0.14, 0.012, 1, 1, 1);
        const arrowBody = new THREE.Mesh(bodyGeo, whiteMat);
        arrowGrp.add(arrowBody);
        
        // Ponta triangular da seta
        const tipShape = new THREE.Shape();
        tipShape.moveTo(0, 0.055);
        tipShape.lineTo(-0.055, -0.025);
        tipShape.lineTo(0.055, -0.025);
        tipShape.closePath();
        
        const tipGeo = new THREE.ShapeGeometry(tipShape);
        const tip = new THREE.Mesh(tipGeo, whiteMat);
        tip.position.set(0, 0.095, 0.006);
        arrowGrp.add(tip);
        
        // Curva da seta
        const bendGeo = new THREE.BoxGeometry(0.08, 0.055, 0.012);
        const bend = new THREE.Mesh(bendGeo, whiteMat);
        bend.position.set(0.045, -0.085, 0);
        bend.rotation.z = -0.6;
        arrowGrp.add(bend);
        
        return arrowGrp;
      }
      
      // Tr√™s setas posicionadas em tri√¢ngulo (120¬∞ entre cada)
      const arrow1 = createArrow();
      arrow1.position.set(0, 0.10, 0);
      arrow1.rotation.z = -2.09; // 120¬∞
      symbolGroup.add(arrow1);
      
      const arrow2 = createArrow();
      arrow2.position.set(-0.09, -0.05, 0);
      arrow2.rotation.z = 0;
      symbolGroup.add(arrow2);
      
      const arrow3 = createArrow();
      arrow3.position.set(0.09, -0.05, 0);
      arrow3.rotation.z = 2.09; // -120¬∞
      symbolGroup.add(arrow3);
      
      // Posiciona s√≠mbolo na frente
      symbolGroup.position.set(0, 0.80, 0.365);
      symbolGroup.scale.set(1.2, 1.2, 1);
      group.add(symbolGroup);

      return group;
    }

    // ==========================
    // CAR SYSTEM
    // ==========================

    function createCarMesh(color) {
      const group = new THREE.Group();
      
      // === MATERIAIS ===
      const paintMat = new THREE.MeshPhongMaterial({ 
          color: color, 
          shininess: 70, 
          specular: 0x333333 
      });
      const paintDarkMat = new THREE.MeshPhongMaterial({ 
          color: new THREE.Color(color).multiplyScalar(0.7), 
          shininess: 60 
      });
      const glassMat = new THREE.MeshPhongMaterial({ 
          color: 0x112233, 
          shininess: 90, 
          specular: 0xffffff,
          opacity: 0.7,
          transparent: true
      });
      const chromeMat = new THREE.MeshPhongMaterial({ 
          color: 0xcccccc, 
          shininess: 120, 
          specular: 0xffffff 
      });
      const bumperMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
      const lightYellow = new THREE.MeshBasicMaterial({ color: 0xffffaa });
      const lightRed = new THREE.MeshBasicMaterial({ color: 0xff2222 });
      const tireMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const rimMat = new THREE.MeshPhongMaterial({ color: 0x999999, shininess: 80 });

      // === 1. CORPO DO CARRO ===
      // Chassi
      const chassis = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.45, 4.0), paintMat);
      chassis.position.y = 0.55;
      chassis.castShadow = true;
      chassis.receiveShadow = true;
      group.add(chassis);

      // Cabine
      const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.55, 2.2), paintMat);
      cabin.position.set(0, 1.05, -0.2); 
      cabin.castShadow = true;
      group.add(cabin);

      // Teto
      const roof = new THREE.Mesh(new THREE.BoxGeometry(1.52, 0.05, 2.0), paintMat);
      roof.position.set(0, 1.33, -0.2);
      group.add(roof);

      // === 2. VIDROS ===
      // Parabrisa
      const windshield = new THREE.Mesh(new THREE.BoxGeometry(1.42, 0.45, 0.05), glassMat);
      windshield.position.set(0, 1.05, 0.9);
      windshield.rotation.x = -0.2;
      group.add(windshield);

      // Vidro Traseiro
      const rearWin = new THREE.Mesh(new THREE.BoxGeometry(1.42, 0.45, 0.05), glassMat);
      rearWin.position.set(0, 1.05, -1.3);
      rearWin.rotation.x = 0.2;
      group.add(rearWin);

      // Vidros Laterais
      const sideGlassL = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.4, 1.8), glassMat);
      sideGlassL.position.set(-0.74, 1.05, -0.2);
      group.add(sideGlassL);
      const sideGlassR = sideGlassL.clone();
      sideGlassR.position.set(0.74, 1.05, -0.2);
      group.add(sideGlassR);

      // === 3. PARACHOQUES E GRELHA ===
      const frontBumper = new THREE.Mesh(new THREE.BoxGeometry(1.85, 0.25, 0.2), bumperMat);
      frontBumper.position.set(0, 0.45, 2.0);
      group.add(frontBumper);

      const rearBumper = new THREE.Mesh(new THREE.BoxGeometry(1.85, 0.25, 0.2), bumperMat);
      rearBumper.position.set(0, 0.45, -2.0);
      group.add(rearBumper);

      // Grade frontal
      const grille = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.2, 0.05), new THREE.MeshLambertMaterial({color: 0x111111}));
      grille.position.set(0, 0.6, 2.01);
      group.add(grille);

      // === 4. LUZES ===
      // Far√≥is (mesh visual) - formato redondo
      const headlightMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
      const headlightGeo = new THREE.CircleGeometry(0.15, 16);
      
      const headL = new THREE.Mesh(headlightGeo, headlightMat);
      headL.position.set(-0.6, 0.6, 2.01);
      group.add(headL);
      const headR = new THREE.Mesh(headlightGeo, headlightMat);
      headR.position.set(0.6, 0.6, 2.01);
      group.add(headR);
      
      // Aro do farol (detalhe)
      const headlightRimMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
      const headlightRimGeo = new THREE.RingGeometry(0.14, 0.18, 16);
      
      const rimL = new THREE.Mesh(headlightRimGeo, headlightRimMat);
      rimL.position.set(-0.6, 0.6, 2.015);
      group.add(rimL);
      const rimR = new THREE.Mesh(headlightRimGeo, headlightRimMat);
      rimR.position.set(0.6, 0.6, 2.015);
      group.add(rimR);
      
      // Luz real do farol esquerdo
      const spotL = new THREE.SpotLight(0xffffcc, 2, 25, Math.PI / 6, 0.5, 1);
      spotL.position.set(-0.6, 0.6, 2.2);
      spotL.target.position.set(-0.6, 0, 10);
      group.add(spotL);
      group.add(spotL.target);
      
      // Luz real do farol direito
      const spotR = new THREE.SpotLight(0xffffcc, 2, 25, Math.PI / 6, 0.5, 1);
      spotR.position.set(0.6, 0.6, 2.2);
      spotR.target.position.set(0.6, 0, 10);
      group.add(spotR);
      group.add(spotR.target);
      
      // Brilho dos far√≥is (glow)
      const glowMat = new THREE.MeshBasicMaterial({ 
        color: 0xffffaa, 
        transparent: true, 
        opacity: 0.4 
      });
      const glowGeo = new THREE.CircleGeometry(0.22, 16);
      const glowL = new THREE.Mesh(glowGeo, glowMat);
      glowL.position.set(-0.6, 0.6, 2.02);
      group.add(glowL);
      const glowR = new THREE.Mesh(glowGeo, glowMat);
      glowR.position.set(0.6, 0.6, 2.02);
      group.add(glowR);

      // Lanternas Traseiras (mesh visual) - formato redondo
      const tailLightGeo = new THREE.CircleGeometry(0.12, 16);
      const tailL = new THREE.Mesh(tailLightGeo, lightRed);
      tailL.position.set(-0.6, 0.6, -2.01);
      tailL.rotation.y = Math.PI;
      group.add(tailL);
      const tailR = new THREE.Mesh(tailLightGeo, lightRed);
      tailR.position.set(0.6, 0.6, -2.01);
      tailR.rotation.y = Math.PI;
      group.add(tailR);
      
      // Aro das lanternas
      const tailRimGeo = new THREE.RingGeometry(0.11, 0.15, 16);
      const tailRimL = new THREE.Mesh(tailRimGeo, headlightRimMat);
      tailRimL.position.set(-0.6, 0.6, -2.015);
      tailRimL.rotation.y = Math.PI;
      group.add(tailRimL);
      const tailRimR = new THREE.Mesh(tailRimGeo, headlightRimMat);
      tailRimR.position.set(0.6, 0.6, -2.015);
      tailRimR.rotation.y = Math.PI;
      group.add(tailRimR);
      
      // Luz vermelha traseira (mais fraca)
      const tailLightL = new THREE.PointLight(0xff0000, 0.5, 5);
      tailLightL.position.set(-0.6, 0.6, -2.1);
      group.add(tailLightL);
      const tailLightR = new THREE.PointLight(0xff0000, 0.5, 5);
      tailLightR.position.set(0.6, 0.6, -2.1);
      group.add(tailLightR);

      // === 5. RETROVISORES ===
      const mirrorL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.12, 0.1), paintMat);
      mirrorL.position.set(-0.85, 1.0, 0.6);
      group.add(mirrorL);
      const mirrorR = mirrorL.clone();
      mirrorR.position.set(0.85, 1.0, 0.6);
      group.add(mirrorR);

      // === 6. RODAS REALISTAS ===
      // Posi√ß√µes das rodas
      const wheelPos = [
        { x: -0.85, z: 1.2 }, { x: 0.85, z: 1.2 }, 
        { x: -0.85, z: -1.2 }, { x: 0.85, z: -1.2 }
      ];

      // Geometrias reutiliz√°veis
      const tireGeo = new THREE.TorusGeometry(0.3, 0.12, 8, 24); // Pneu redondo (Torus)
      const hubGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.15, 12); // Calota

      wheelPos.forEach(p => {
        const wGroup = new THREE.Group();
        wGroup.position.set(p.x, 0.35, p.z);

        // Pneu
        const tire = new THREE.Mesh(tireGeo, tireMat);
        tire.rotation.y = Math.PI / 2; // Gira o torus para ficar em p√©
        wGroup.add(tire);

        // Calota
        const hub = new THREE.Mesh(hubGeo, rimMat);
        hub.rotation.z = Math.PI / 2;
        wGroup.add(hub);

        group.add(wGroup);
      });

      return group;
    }

    // Sistema de rotas para carros
    // Ruas centrais: horizontal em Z=0 e vertical em X=0
    // Largura da rua: 7 metros, cada faixa ~3.5m
    // Centro de cada faixa: ~1.75m do centro da rua
    // Carros t√™m ~2m de largura, ent√£o offset = 1.0 para ficar bem centralizado na faixa
    
    const LANE_OFFSET = 1.0; // Centro da faixa (n√£o muito perto da cal√ßada)
    
    function spawnTraffic() {
      const colors = [0xff0000, 0x0000ff, 0x111111, 0x00aa00];
      
      // 4 carros, cada um em sua pr√≥pria faixa SEPARADA
      // Offset menor para carros ficarem mais no centro da rua
      const carConfigs = [
        // Carro 1: Oeste ‚Üí Leste (faixa sul Z = -1.0)
        { startX: -90, startZ: -LANE_OFFSET, dirX: 1, dirZ: 0, rotY: Math.PI / 2, baseSpeed: 6 },
        // Carro 2: Leste ‚Üí Oeste (faixa norte Z = +1.0)  
        { startX: 90, startZ: LANE_OFFSET, dirX: -1, dirZ: 0, rotY: -Math.PI / 2, baseSpeed: 6 },
        // Carro 3: Norte ‚Üí Sul (faixa leste X = +1.0)
        { startX: LANE_OFFSET, startZ: -90, dirX: 0, dirZ: 1, rotY: 0, baseSpeed: 6 },
        // Carro 4: Sul ‚Üí Norte (faixa oeste X = -1.0)
        { startX: -LANE_OFFSET, startZ: 90, dirX: 0, dirZ: -1, rotY: Math.PI, baseSpeed: 6 }
      ];
      
      for (let i = 0; i < 4; i++) {
        const cfg = carConfigs[i];
        const color = colors[i];
        
        const car = createCarMesh(color);
        car.position.set(cfg.startX, 0, cfg.startZ);
        car.rotation.y = cfg.rotY;
        
        car.userData = {
          dirX: cfg.dirX,
          dirZ: cfg.dirZ,
          baseSpeed: cfg.baseSpeed,
          startX: cfg.startX,
          startZ: cfg.startZ,
          laneZ: cfg.startZ, // Faixa fixa em Z (para carros horizontais)
          laneX: cfg.dirX !== 0 ? null : cfg.startX, // Faixa fixa em X (para carros verticais)
          isHorizontal: cfg.dirX !== 0,
          waitTimer: 0 // Tempo esperando no cruzamento
        };
        
        scene.add(car);
        cars.push(car);
      }
    }

    function updateCars(dt) {
      if (carHitCooldown > 0) carHitCooldown -= dt;
      
      const CAR_LENGTH = 5; // Comprimento do carro
      const SAFE_DISTANCE = 7; // Dist√¢ncia segura entre carros
      const CROSSING_SIZE = 5; // Tamanho do cruzamento
      
      cars.forEach((car, index) => {
        const u = car.userData;
        const pos = car.position;
        
        // Verificar se est√° no cruzamento
        const inCrossing = Math.abs(pos.x) < CROSSING_SIZE && Math.abs(pos.z) < CROSSING_SIZE;
        
        // Verificar se est√° se aproximando do cruzamento
        let approachingCrossing = false;
        if (u.isHorizontal) {
          // Carro horizontal - verifica se est√° chegando no X=0
          const distToCrossing = Math.abs(pos.x);
          approachingCrossing = distToCrossing < CROSSING_SIZE + SAFE_DISTANCE && distToCrossing > CROSSING_SIZE;
        } else {
          // Carro vertical - verifica se est√° chegando no Z=0
          const distToCrossing = Math.abs(pos.z);
          approachingCrossing = distToCrossing < CROSSING_SIZE + SAFE_DISTANCE && distToCrossing > CROSSING_SIZE;
        }
        
        let shouldStop = false;
        
        // Se aproximando do cruzamento, verificar se h√° carro perpendicular no cruzamento
        if (approachingCrossing) {
          for (let j = 0; j < cars.length; j++) {
            if (j === index) continue;
            
            const otherCar = cars[j];
            const otherPos = otherCar.position;
            const otherU = otherCar.userData;
            
            // S√≥ verifica carros em dire√ß√£o perpendicular
            if (u.isHorizontal === otherU.isHorizontal) continue;
            
            // O outro carro est√° no cruzamento ou muito perto?
            const otherInCrossing = Math.abs(otherPos.x) < CROSSING_SIZE + 2 && Math.abs(otherPos.z) < CROSSING_SIZE + 2;
            
            if (otherInCrossing) {
              // Prioridade: quem j√° est√° no cruzamento passa primeiro
              // Quem est√° chegando espera
              shouldStop = true;
              break;
            }
          }
        }
        
        // Verificar colis√£o com carro na mesma faixa (atr√°s/frente)
        for (let j = 0; j < cars.length; j++) {
          if (j === index) continue;
          
          const otherCar = cars[j];
          const otherPos = otherCar.position;
          const otherU = otherCar.userData;
          
          // S√≥ verifica carros na mesma dire√ß√£o
          if (u.isHorizontal !== otherU.isHorizontal) continue;
          
          // Calcular dist√¢ncia na dire√ß√£o de movimento
          let distAhead = 0;
          let otherIsAhead = false;
          
          if (u.isHorizontal) {
            // Mesma faixa Z?
            if (Math.abs(pos.z - otherPos.z) < 2) {
              if (u.dirX > 0) {
                distAhead = otherPos.x - pos.x;
                otherIsAhead = distAhead > 0;
              } else {
                distAhead = pos.x - otherPos.x;
                otherIsAhead = distAhead > 0;
              }
            }
          } else {
            // Mesma faixa X?
            if (Math.abs(pos.x - otherPos.x) < 2) {
              if (u.dirZ > 0) {
                distAhead = otherPos.z - pos.z;
                otherIsAhead = distAhead > 0;
              } else {
                distAhead = pos.z - otherPos.z;
                otherIsAhead = distAhead > 0;
              }
            }
          }
          
          // Se h√° carro √† frente muito perto, para
          if (otherIsAhead && distAhead < SAFE_DISTANCE && distAhead > 0) {
            shouldStop = true;
            break;
          }
        }
        
        // Movimento
        if (!shouldStop) {
          car.position.x += u.dirX * u.baseSpeed * dt;
          car.position.z += u.dirZ * u.baseSpeed * dt;
          u.waitTimer = 0;
        } else {
          u.waitTimer += dt;
          // Se esperou muito tempo (5 segundos), for√ßa passagem
          if (u.waitTimer > 5) {
            car.position.x += u.dirX * u.baseSpeed * dt;
            car.position.z += u.dirZ * u.baseSpeed * dt;
          }
        }
        
        // Manter na faixa correta (evita drift)
        if (u.isHorizontal) {
          car.position.z = u.laneZ;
        } else {
          car.position.x = u.startX;
        }
        
        // Respawn quando sai do mapa
        const exitLimit = 95;
        let needsRespawn = false;
        
        if (u.dirX > 0 && car.position.x > exitLimit) needsRespawn = true;
        if (u.dirX < 0 && car.position.x < -exitLimit) needsRespawn = true;
        if (u.dirZ > 0 && car.position.z > exitLimit) needsRespawn = true;
        if (u.dirZ < 0 && car.position.z < -exitLimit) needsRespawn = true;
        
        if (needsRespawn) {
          car.position.x = u.startX;
          car.position.z = u.startZ;
          u.waitTimer = 0;
        }
        
        // --- COLIS√ÉO CARRO vs PLAYER ---
        const playerPos = player.object.position;
        const carPos = car.position;
          
        // Se o jogador est√° ca√≠do (atropelado), carros passam por cima sem colidir
        if (player.isKnockedDown) {
          // N√£o faz nada - carro passa por cima
        } else {
          // Dimens√µes do carro
          const carHalfWidth = 1.0;   // Metade da largura
          const carHalfLength = 2.2;  // Metade do comprimento
          const playerRadius = 0.35;
          
          // Vetor do carro para o jogador
          const dx = playerPos.x - carPos.x;
          const dz = playerPos.z - carPos.z;
          
          // Coordenadas locais do carro (considerando rota√ß√£o)
          const carRotY = car.rotation.y;
          const cosR = Math.cos(-carRotY);
          const sinR = Math.sin(-carRotY);
          const localX = dx * cosR - dz * sinR;
          const localZ = dx * sinR + dz * cosR;
          
          // Est√° dentro do ret√¢ngulo do carro (horizontalmente)?
          const insideCarX = Math.abs(localX) < carHalfWidth + playerRadius;
          const insideCarZ = Math.abs(localZ) < carHalfLength + playerRadius;
          const insideCar = insideCarX && insideCarZ;
          
          // COLIS√ÉO: Jogador est√° dentro da √°rea do carro (qualquer altura) = ATROPELAMENTO
          if (insideCar && carHitCooldown <= 0) {
            // Empurra para fora primeiro
            const overlapX = (carHalfWidth + playerRadius) - Math.abs(localX);
            const overlapZ = (carHalfLength + playerRadius) - Math.abs(localZ);
            
            let pushLocalX = 0, pushLocalZ = 0;
            if (overlapX < overlapZ) {
              pushLocalX = Math.sign(localX) * (overlapX + 0.3);
            } else {
              pushLocalZ = Math.sign(localZ) * (overlapZ + 0.3);
            }
            
            // Converte para coordenadas globais
            const cosRi = Math.cos(carRotY);
            const sinRi = Math.sin(carRotY);
            playerPos.x += pushLocalX * cosRi - pushLocalZ * sinRi;
            playerPos.z += pushLocalX * sinRi + pushLocalZ * cosRi;
            
            // ATROPELAMENTO! (n√£o importa a altura - pulando ou n√£o)
            applyDamage(1, "Atropelamento");
            carHitCooldown = 3.5;
            
            player.isKnockedDown = true;
            player.recoverTimer = 3.0;
            player.object.rotation.x = -Math.PI / 2;
            player.baseY = 0.2;
            playerPos.y = 0.2;
            player.velocity.x = 0;
            player.velocity.z = 0;
            player.verticalVelocity = 0;
          }
        } // fecha o else do isKnockedDown
      });
    }

    // ==========================
    // MONSTERS / BAGS
    // ==========================

    class Monster {
      constructor(type, config, position) {
        this.type = type;
        this.color = config.color;
        this.speed = config.speed;
        this.state = "alive";
        this.hp = 2;
        
        // Cria√ß√£o inicial
        this.mesh = this.createMonsterMesh();
        this.mesh.position.copy(position);
        this.mesh.userData.monster = this;
        
        // Dados de movimento
        this.wanderAngle = Math.random() * Math.PI * 2;
        this.bobOffset = Math.random() * Math.PI * 2;
        this.targetDir = new THREE.Vector3(Math.cos(this.wanderAngle), 0, Math.sin(this.wanderAngle));
        this.touchCooldown = 0;
        this.collisionRadius = 0.45;

        // Combate
        this.combatState = "idle"; 
        this.combatTimer = 0;
        this.biteCooldown = 0;
      }

      // --- CRIA O MONSTRO (VIVO) ---
      createMonsterMesh() {
        const group = new THREE.Group();

        // Material Pl√°stico Brilhante
        const plasticMat = new THREE.MeshPhongMaterial({ 
            color: this.color,
            shininess: 90,        // Muito brilho
            specular: 0x444444,   // Reflexo acinzentado
            flatShading: false    // Suave para parecer esticado
        });

        // Corpo "Gosmento/Amassado"
        // Dodecaedro detalhado para ficar redondinho mas irregular
        const bodyGeo = new THREE.DodecahedronGeometry(0.42, 1); 
        const pos = bodyGeo.attributes.position;
        // Deforma levemente os v√©rtices para n√£o ser perfeito
        for(let i=0; i < pos.count; i++){
            pos.setX(i, pos.getX(i) + (Math.random()-0.5)*0.08);
            pos.setY(i, pos.getY(i) + (Math.random()-0.5)*0.08);
            pos.setZ(i, pos.getZ(i) + (Math.random()-0.5)*0.08);
        }
        bodyGeo.computeVertexNormals();

        const body = new THREE.Mesh(bodyGeo, plasticMat);
        body.position.y = 0.45;
        // Escala levemente achatada na base
        body.scale.set(1, 0.9, 1);
        group.add(body);
        group.userData.body = body;
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // OUTLINE/CONTORNO BRANCO (para destacar monstros da cor certa)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const outlineGeo = new THREE.DodecahedronGeometry(0.52, 1); // Maior que o corpo
        const outlineMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff,
            side: THREE.BackSide, // Renderiza s√≥ o lado de tr√°s
            transparent: true,
            opacity: 0.9
        });
        const outline = new THREE.Mesh(outlineGeo, outlineMat);
        outline.position.y = 0.45;
        outline.scale.set(1, 0.9, 1);
        outline.visible = false; // Come√ßa invis√≠vel
        outline.name = "monster_outline";
        group.add(outline);
        group.userData.outline = outline;

        // Olhos (Grandes e Expressivos)
        const eyeGeo = new THREE.SphereGeometry(0.10, 16, 16);
        const eyeWhite = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const eyeL = new THREE.Mesh(eyeGeo, eyeWhite);
        const eyeR = new THREE.Mesh(eyeGeo, eyeWhite);
        eyeL.position.set(-0.15, 0.55, 0.32);
        eyeR.position.set( 0.15, 0.55, 0.32);
        group.add(eyeL, eyeR);

        // Pupilas
        const pupilGeo = new THREE.SphereGeometry(0.04, 8, 8);
        const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const pL = new THREE.Mesh(pupilGeo, pupilMat);
        const pR = new THREE.Mesh(pupilGeo, pupilMat);
        pL.position.set(0, 0, 0.09); // Relativo ao olho
        pR.position.set(0, 0, 0.09);
        eyeL.add(pL);
        eyeR.add(pR);

        // Perninhas Curtas (Para andar)
        const legGeo = new THREE.CylinderGeometry(0.06, 0.04, 0.25, 8);
        const legL = new THREE.Mesh(legGeo, plasticMat);
        const legR = new THREE.Mesh(legGeo, plasticMat);
        legL.position.set(-0.15, 0.15, 0);
        legR.position.set( 0.15, 0.15, 0);
        group.add(legL, legR);
        group.userData.legL = legL;
        group.userData.legR = legR;

        return group;
      }

      // --- CRIA O SACO DE LIXO (MORTO/ITEM) ---
      createBagMesh() {
        const group = new THREE.Group();

        // Material de Saco de Lixo (Pl√°stico Escuro ou Colorido)
        // Usamos a cor do lixo, mas um pouco mais escura para parecer "cheio"
        const bagColor = new THREE.Color(this.color).multiplyScalar(0.9);
        
        const plasticMat = new THREE.MeshPhongMaterial({ 
            color: bagColor,
            shininess: 100,      // Pl√°stico bem liso
            specular: 0x666666,  // Reflexo forte
            side: THREE.DoubleSide
        });

        // 1. O Saco (Base gordinha e irregular)
        const bagGeo = new THREE.DodecahedronGeometry(0.35, 2); // Mais detalhado
        const pos = bagGeo.attributes.position;
        // Amassa o saco
        for(let i=0; i < pos.count; i++){
             const amp = 0.04;
             pos.setX(i, pos.getX(i) + (Math.random()-0.5)*amp);
             pos.setY(i, pos.getY(i) + (Math.random()-0.5)*amp);
             pos.setZ(i, pos.getZ(i) + (Math.random()-0.5)*amp);
        }
        bagGeo.computeVertexNormals();

        const bagBody = new THREE.Mesh(bagGeo, plasticMat);
        bagBody.position.y = 0.35;
        // Achata o fundo (como um saco pesado no ch√£o)
        bagBody.scale.set(1.1, 0.9, 1.1); 
        group.add(bagBody);

        // 2. O N√≥ (Parte de cima amarrada)
        const knotGroup = new THREE.Group();
        knotGroup.position.set(0, 0.70, 0);
        
        // O "Pesco√ßo" do n√≥
        const neckGeo = new THREE.CylinderGeometry(0.08, 0.15, 0.15, 12);
        const neck = new THREE.Mesh(neckGeo, plasticMat);
        knotGroup.add(neck);

        // A "Boca" do saco (sobras de pl√°stico saindo do n√≥)
        const topFanGeo = new THREE.ConeGeometry(0.18, 0.2, 12, 1, true);
        const topFan = new THREE.Mesh(topFanGeo, plasticMat);
        topFan.position.y = 0.15;
        topFan.rotation.x = Math.PI; // Invertido (aberto pra cima)
        
        // Deforma a boca pra parecer tecido/pl√°stico solto
        const tPos = topFanGeo.attributes.position;
        for(let i=0; i < tPos.count; i++){
            tPos.setX(i, tPos.getX(i) + (Math.random()-0.5)*0.1);
            tPos.setZ(i, tPos.getZ(i) + (Math.random()-0.5)*0.1);
        }
        topFanGeo.computeVertexNormals();
        
        knotGroup.add(topFan);
        
        // Inclina o n√≥ um pouco para dar naturalidade
        knotGroup.rotation.z = 0.2;
        knotGroup.rotation.x = 0.1;
        
        group.add(knotGroup);

        group.userData.isBag = true;
        return group;
      }

      // Fun√ß√µes de Efeito (Mantidas)
      setGlow(intensity) {
        const body = this.mesh?.userData?.body;
        if (!body) return;
        if (!body.material.emissive) body.material.emissive = new THREE.Color();
        const glowColor = new THREE.Color(this.color).lerp(new THREE.Color(0xffffff), 0.5);
        body.material.emissive.copy(glowColor);
        body.material.emissiveIntensity = intensity;
      }

      clearGlow() {
        const body = this.mesh?.userData?.body;
        if (body) body.material.emissiveIntensity = 0;
      }

      toBag() {
        if (this.state === "bag") return;
        this.state = "bag";
        this.clearGlow();
        spawnBurstParticles(this.mesh.position, this.color, 16, 0.5, 3.0);
        playTransformSound();

        const pos = this.mesh.position.clone();
        scene.remove(this.mesh);
        this.mesh = this.createBagMesh();
        this.mesh.position.copy(pos);
        this.mesh.userData.monster = this;
        scene.add(this.mesh);

        this.collisionRadius = SELF_COLLISION_RADIUS_BAG;
      }

      applyDamage(dmg) {
        if (this.state !== "alive") return;
        this.hp -= dmg;
        playHitSound();
        this.setGlow(0.6); // Flash ao tomar dano
        setTimeout(() => this.clearGlow(), 80);

        this.speed *= 1.05; // Fica mais r√°pido bravo
        if (this.hp <= 0) {
          this.clearGlow();
          this.toBag();
        }
      }

      update(dt, playerPos) {
        const pos = this.mesh.position;

        if (this.state === "alive") {
          // Usa vetores tempor√°rios globais em vez de criar novos
          const toPlayer = _tempVec3_2.subVectors(playerPos, pos).setY(0);
          const dist = toPlayer.length();

          if (this.biteCooldown > 0) this.biteCooldown -= dt;
          if (this.combatTimer > 0) this.combatTimer -= dt;

          // Area urbana circular - monstros ficam dentro
          const urbanLimit = 28;
          const softLimit = 22;
          const distFromCenter = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
          const isNearEdge = distFromCenter > softLimit;
          const isOutside = distFromCenter > urbanLimit;
          
          // Timer de mudanca de direcao
          if (!this.dirChangeTimer) this.dirChangeTimer = Math.random() * 3;
          this.dirChangeTimer -= dt;
          
          if (this.combatState === "idle") {
            if (dist < BITE_RANGE && this.biteCooldown <= 0) {
              this.combatState = "chase";
            } else {
              // Fora da area - volta imediatamente para o centro
              if (isOutside) {
                // Calcula vetor para centro sem criar novo objeto
                const toCenterX = -pos.x;
                const toCenterZ = -pos.z;
                const toCenterLen = Math.sqrt(toCenterX * toCenterX + toCenterZ * toCenterZ) || 1;
                this.targetDir.set(toCenterX / toCenterLen, 0, toCenterZ / toCenterLen);
                this.wanderAngle = Math.atan2(this.targetDir.x, this.targetDir.z);
                this.dirChangeTimer = 1;
              }
              // Perto da borda - ajusta dire√ß√£o
              else if (isNearEdge && this.dirChangeTimer <= 0) {
                const currentAngle = this.wanderAngle;
                const awayFromCenterAngle = Math.atan2(pos.x, pos.z);
                
                let newAngle = currentAngle + (Math.random() - 0.5) * Math.PI;
                
                const angleDiff = Math.abs(newAngle - awayFromCenterAngle);
                if (angleDiff < Math.PI * 0.4) {
                  newAngle = newAngle + Math.PI;
                }
                
                this.wanderAngle = newAngle;
                this.targetDir.set(Math.cos(this.wanderAngle), 0, Math.sin(this.wanderAngle));
                this.dirChangeTimer = 2 + Math.random() * 2;
              }
              // Dentro da area - patrulha aleat√≥ria
              else if (this.dirChangeTimer <= 0 && !isNearEdge) {
                this.wanderAngle = Math.random() * Math.PI * 2;
                this.targetDir.set(Math.cos(this.wanderAngle), 0, Math.sin(this.wanderAngle));
                this.dirChangeTimer = 3 + Math.random() * 4;
              }
            }
          }
          else if (this.combatState === "chase") {
             this.setGlow(0.2 + Math.sin(globalTime*10)*0.2);
             if (dist > BITE_HOLD_RANGE) { this.combatState = "idle"; this.clearGlow(); }
             else if (dist < 1.3) { this.combatState = "windup"; this.combatTimer = BITE_WINDUP_TIME; }
          }
          else if (this.combatState === "windup") {
             this.setGlow(0.8);
             if (this.combatTimer <= 0) {
                 this.combatState = "recover";
                 this.biteCooldown = BITE_COOLDOWN;
                 if (dist < 1.5) {
                     const dmg = DAMAGE_BY_TYPE[this.type] || 1.0;
                     applyDamage(dmg, `Mordida de ${this.type}`);
                 }
             }
          }
          else if (this.combatState === "recover") {
              this.clearGlow();
              if (this.biteCooldown <= 0) this.combatState = "idle";
          }

          // Movimento - usa vetor tempor√°rio
          let speedVal = this.speed;
          const moveVec = _tempVec3_3;
          
          if (this.combatState === "chase") {
            moveVec.copy(toPlayer).normalize();
          } else if (this.combatState === "recover") {
            if (isNearEdge) {
              // Vetor para centro
              const len = distFromCenter || 1;
              moveVec.set(-pos.x / len, 0, -pos.z / len);
            } else {
              moveVec.copy(toPlayer).normalize().negate();
            }
            speedVal *= 0.4;
          } else {
            moveVec.copy(this.targetDir);
          }
          
          if (this.combatState === "windup") {
            speedVal = 0;
          }

          if (speedVal > 0) {
              pos.addScaledVector(moveVec, speedVal * dt);
              this.mesh.rotation.y = Math.atan2(moveVec.x, moveVec.z);
          }
          
          // Limite RIGIDO circular - SEMPRE aplica
          const newDist = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
          if (newDist > urbanLimit) {
            const scale = urbanLimit / newDist;
            pos.x *= scale;
            pos.z *= scale;
          }

          // === SEPARA√á√ÉO ENTRE MONSTROS ===
          // Evita que monstros se sobreponham
          const MONSTER_SEPARATION_RADIUS = 1.5; // Dist√¢ncia m√≠nima entre monstros
          const SEPARATION_FORCE = 3.0; // For√ßa de separa√ß√£o
          
          for (let i = 0; i < monsters.length; i++) {
            const other = monsters[i];
            if (other === this || !other.mesh || other.state !== "monster") continue;
            
            const otherPos = other.mesh.position;
            const dx = pos.x - otherPos.x;
            const dz = pos.z - otherPos.z;
            const distSq = dx * dx + dz * dz;
            
            if (distSq < MONSTER_SEPARATION_RADIUS * MONSTER_SEPARATION_RADIUS && distSq > 0.01) {
              const dist = Math.sqrt(distSq);
              const overlap = MONSTER_SEPARATION_RADIUS - dist;
              
              // Normaliza e aplica for√ßa de separa√ß√£o
              const pushX = (dx / dist) * overlap * SEPARATION_FORCE * dt;
              const pushZ = (dz / dist) * overlap * SEPARATION_FORCE * dt;
              
              pos.x += pushX;
              pos.z += pushZ;
            }
          }
          
          // Reaplicar limite ap√≥s separa√ß√£o
          const finalDist = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
          if (finalDist > urbanLimit) {
            const scale = urbanLimit / finalDist;
            pos.x *= scale;
            pos.z *= scale;
          }

          // Animacao
          const hop = Math.abs(Math.sin(globalTime * 8 + this.bobOffset));
          this.mesh.position.y = 0.45 + hop * 0.15;
          
          const legL = this.mesh.userData.legL;
          const legR = this.mesh.userData.legR;
          if (legL && legR) {
              legL.rotation.x = Math.sin(globalTime * 12) * 0.5;
              legR.rotation.x = -Math.sin(globalTime * 12) * 0.5;
          }

        } else if (this.state === "bag") {
          this.mesh.position.y = 0.05; 
          this.mesh.rotation.y = 0;
        }
      }
    }


    function spawnInitialMonsters() {
      monsters.forEach(m => m.mesh && scene.remove(m.mesh));
      monsters = [];

      const count = Math.floor(
        MONSTER_SPAWN_MIN +
        Math.random() * (MONSTER_SPAWN_MAX - MONSTER_SPAWN_MIN + 1)
      );

      const types = Object.keys(MONSTER_CONFIG);
      const spawnRadius = 18; // Spawn mais para dentro (longe da borda)

      for (let i = 0; i < count; i++) {
        const type = types[Math.floor(Math.random() * types.length)];
        const cfg = MONSTER_CONFIG[type];

        let pos;
        let attempts = 0;
        do {
          // Spawn em coordenadas circulares - mais para dentro
          const angle = Math.random() * Math.PI * 2;
          const radius = 5 + Math.random() * (spawnRadius - 5); // Entre 5 e 18
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;
          pos = new THREE.Vector3(x, 0.4, z);
          
          // Verifica se n√£o est√° muito perto de outro monstro
          let tooClose = false;
          for (const m of monsters) {
            if (m.mesh && m.mesh.position.distanceTo(pos) < 3) {
              tooClose = true;
              break;
            }
          }
          if (!tooClose) break;
          attempts++;
        } while (attempts < 10);

        const m = new Monster(type, cfg, pos);
        // Dire√ß√£o inicial aleat√≥ria
        m.wanderAngle = Math.random() * Math.PI * 2;
        m.targetDir.set(Math.cos(m.wanderAngle), 0, Math.sin(m.wanderAngle));
        m.dirChangeTimer = 2 + Math.random() * 3;
        
        monsters.push(m);
        scene.add(m.mesh);
        
        // Atualizar destaques ao spawnar
        updateMonsterHighlights();
      }

      timeSinceLastSpawn = 0;
    }

    function spawnMoreMonsters(delta) {
      timeSinceLastSpawn += delta;
      if (timeSinceLastSpawn < MONSTER_SPAWN_INTERVAL) return;
      timeSinceLastSpawn = 0;

      const active = monsters.filter(m => m.mesh !== null);
      if (active.length >= MONSTER_MAX) return;

      const toSpawn = 3;
      const types = Object.keys(MONSTER_CONFIG);
      const spawnRadius = 18; // Mais para dentro

      for (let i = 0; i < toSpawn; i++) {
        const type = types[Math.floor(Math.random() * types.length)];
        const cfg = MONSTER_CONFIG[type];

        let pos;
        let attempts = 0;
        do {
          const angle = Math.random() * Math.PI * 2;
          const radius = 5 + Math.random() * (spawnRadius - 5);
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;
          
          // Nao spawna muito perto do jogador
          const playerDist = Math.sqrt(
            Math.pow(x - player.object.position.x, 2) + 
            Math.pow(z - player.object.position.z, 2)
          );
          if (playerDist < 8) {
            attempts++;
            continue;
          }
          
          pos = new THREE.Vector3(x, 0.4, z);
          break;
        } while (attempts < 15);
        
        if (!pos) continue;

        const m = new Monster(type, cfg, pos);
        // Dire√ß√£o inicial aleat√≥ria
        m.wanderAngle = Math.random() * Math.PI * 2;
        m.targetDir.set(Math.cos(m.wanderAngle), 0, Math.sin(m.wanderAngle));
        m.dirChangeTimer = 2 + Math.random() * 3;
        
        monsters.push(m);
        scene.add(m.mesh);
        
        // Atualizar destaques ao spawnar
        updateMonsterHighlights();
      }
    }

    // ==========================
    // PROJECTILES
    // ==========================

    class Projectile {
      constructor(origin, direction, color, speed = PROJECTILE_SPEED, isSniper = false) {
        this.position = origin.clone();
        this.direction = direction.clone().normalize();
        this.life = PROJECTILE_LIFETIME;
        this.color = color || 0xffffff;
        this.speed = speed;
        this.isSniper = isSniper;

        const size = isSniper ? 0.15 : 0.08;
        const geo = new THREE.SphereGeometry(size, 8, 8);
        const mat = new THREE.MeshBasicMaterial({ color: this.color });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.copy(this.position);
        
        // Trail para tiro sniper
        if (isSniper) {
          const trailGeo = new THREE.CylinderGeometry(0.02, 0.06, 0.8, 8);
          const trailMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffaa, 
            transparent: true, 
            opacity: 0.6 
          });
          this.trail = new THREE.Mesh(trailGeo, trailMat);
          this.trail.rotation.x = Math.PI / 2;
          this.trail.position.z = -0.4; // Trail atr√°s do proj√©til (mais curto)
          this.mesh.add(this.trail);
        }
        
        scene.add(this.mesh);
      }

      update(dt) {
        this.life -= dt;
        if (this.life <= 0) {
          this.destroy();
          return false;
        }

        this.position.addScaledVector(this.direction, this.speed * dt);
        this.mesh.position.copy(this.position);
        
        // Rotaciona o proj√©til na dire√ß√£o do movimento
        if (this.isSniper) {
          this.mesh.lookAt(_tempVec3_4.copy(this.position).add(this.direction));
        }

        const t = this.life / PROJECTILE_LIFETIME;
        const s = 0.9 + (1 - t) * 0.4;
        this.mesh.scale.setScalar(s);

        for (const monster of monsters) {
          if (monster.state !== "alive" || !monster.mesh) continue;
          const d = monster.mesh.position.distanceTo(this.position);
          const hitRadius = this.isSniper ? 0.7 : 0.55;
          if (d < hitRadius) {
            if (monster.type === currentWeapon) {
              // Sniper = instakill (999 de dano)
              const damage = this.isSniper ? 999 : 1;
              monster.applyDamage(damage);
              const particleCount = this.isSniper ? 20 : 8;
              const particleSpeed = this.isSniper ? 8.0 : 4.0;
              spawnBurstParticles(this.position, monster.color, particleCount, 0.25, particleSpeed);
            } else {
              spawnBurstParticles(this.position, 0x666666, 4, 0.15, 2.0);
            }
            this.destroy();
            return false;
          }
        }

        return true;
      }

      destroy() {
        if (this.mesh) {
          scene.remove(this.mesh);
          this.mesh.geometry.dispose();
          this.mesh.material.dispose();
          if (this.trail) {
            this.trail.geometry.dispose();
            this.trail.material.dispose();
          }
          this.mesh = null;
        }
      }
    }

    // ==========================
    // PARTICLES
    // ==========================

    const particles = [];

    function spawnBurstParticles(position, color, count, radius, speed) {
      const col = new THREE.Color(color);
      for (let i = 0; i < count; i++) {
        const geo = new THREE.SphereGeometry(0.04, 4, 4);
        const mat = new THREE.MeshBasicMaterial({ color: col });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(position);

        const dir = new THREE.Vector3(
          (Math.random() - 0.5),
          Math.random(),
          (Math.random() - 0.5)
        ).normalize();

        particles.push({
          mesh,
          vel: dir.multiplyScalar(speed * (0.4 + Math.random() * 0.8)),
          life: 0.4 + Math.random() * 0.3
        });
        scene.add(mesh);
      }
    }

    function spawnRainParticlesAboveBin(bin, color, count) {
      const col = new THREE.Color(color);
      const binPos = bin.mesh.position.clone();
      for (let i = 0; i < count; i++) {
        const geo = new THREE.SphereGeometry(0.03, 4, 4);
        const mat = new THREE.MeshBasicMaterial({ color: col });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(
          binPos.x + (Math.random() - 0.5) * 0.8,
          binPos.y + 1.6 + Math.random() * 0.4,
          binPos.z + (Math.random() - 0.5) * 0.8
        );
        particles.push({
          mesh,
          vel: new THREE.Vector3(0, -2 - Math.random() * 2, 0),
          life: 0.6 + Math.random() * 0.4
        });
        scene.add(mesh);
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt;
        if (p.life <= 0) {
          scene.remove(p.mesh);
          p.mesh.geometry.dispose();
          p.mesh.material.dispose();
          particles.splice(i, 1);
          continue;
        }
        p.mesh.position.addScaledVector(p.vel, dt);
        const alpha = THREE.MathUtils.clamp(p.life / 0.4, 0, 1);
        const scale = 0.7 + 0.6 * alpha;
        p.mesh.scale.setScalar(scale);
      }
    }

    // ==========================
    // UI & VIDA
    // ==========================

    function updateHUD() {
      scoreText.textContent = currentScore.toString();
      missionTextEl.textContent = `Recicle ${TARGET_CORRECT} sacos corretamente para vencer!`;
      
      const trashEl = document.getElementById("currentTrashText");
      
      if (!currentHeldBag) {
        trashEl.textContent = "Nada";
        trashEl.style.backgroundColor = "#f1f2f6";
        trashEl.style.color = "#aaa";
      } else {
        const type = currentHeldBag.type;
        const colorHex = MONSTER_CONFIG[type]?.color || 0xffffff;
        const colorCSS = "#" + colorHex.toString(16).padStart(6, "0");
        
        trashEl.textContent = type;
        trashEl.style.backgroundColor = colorCSS;
        // L√≥gica simples de contraste: se for amarelo, texto preto, sen√£o branco
        trashEl.style.color = (type === "Metal" || type === "Vidro") ? "#000" : "#fff";
      }
    }

    function renderHearts() {
      const fragments = [];
      let hp = Math.max(0, Math.min(MAX_HEARTS, playerHearts));
      for (let i = 0; i < MAX_HEARTS; i++) {
        let cls = "heart";
        if (hp >= 1) {
          cls += " full";
          hp -= 1;
        } else if (hp >= 0.5) {
          cls += " half";
          hp -= 0.5;
        }
        fragments.push(`<div class="${cls}"></div>`);
      }
      heartsEl.innerHTML = fragments.join("");
    }

    // Vari√°vel para evitar atualiza√ß√£o desnecess√°ria
    let _lastStaminaPercent = -1;
    
    function updateStaminaHUD() {
      if (!_cachedStaminaBar) {
        _cachedStaminaBar = document.getElementById("stamina-bar");
        if (!_cachedStaminaBar) return;
      }
      
      const percent = Math.round((playerStamina / MAX_STAMINA) * 100);
      
      // S√≥ atualiza se mudou (evita reflow/repaint desnecess√°rio)
      if (percent === _lastStaminaPercent) return;
      _lastStaminaPercent = percent;
      
      _cachedStaminaBar.style.width = percent + "%";
      
      // Muda cor baseado no n√≠vel
      if (percent <= 0) {
        _cachedStaminaBar.className = "depleted";
      } else if (percent < 30) {
        _cachedStaminaBar.className = "low";
      } else {
        _cachedStaminaBar.className = "";
      }
    }

    function applyDamage(amount, sourceLabel = "Dano") {
      // N√£o aplica dano se o jogo acabou (vit√≥ria ou game over)
      if (gameCompleted || isGameOver) return;
      
      playerHearts = Math.max(0, playerHearts - amount);
      renderHearts();
      showMessage(sourceLabel, `Voc√™ sofreu ${amount} de dano.`, 900);
      
      // Verifica se morreu
      if (playerHearts <= 0) {
        isGameOver = true;
        showMessage("Game Over", "Voc√™ ficou sem vida. Reiniciando em 2 segundos...", 2000);
        
        // Reinicia o jogo ap√≥s 2 segundos
        setTimeout(function() {
          resetGame();
        }, 2000);
      }
    }

    function showMessage(title, body, duration = 2200) {
      clearTimeout(messageTimeout);
      messageTitleEl.textContent = title;
      messageBodyEl.textContent = body;
      messageBox.classList.add("visible");
      if (duration > 0) {
        messageTimeout = setTimeout(() => {
          messageBox.classList.remove("visible");
        }, duration);
      }
    }

    function showVictory() {
      gameCompleted = true;
      hudEl.style.display = "none";
      controlsHint.style.display = "none";
      document.getElementById('ammoHud').style.display = "none";
      victoryScreen.style.display = "flex";
    }

    function resetGame() {
      // Reseta flags de estado
      gameCompleted = false;
      isGameOver = false;
      
      // Reseta pontua√ß√£o e miss√£o
      currentScore = 0;
      correctCount = 0;
      currentHeldBag = null;
      destroyHeldBagVisual();
      timeSinceLastSpawn = 0;
      
      // Reseta contadores de casas e pr√©dios
      window.houseCount = 0;
      window.buildingCount = 0;
      window.buildingSlots = 0;
      
      // Reseta cache de stamina para for√ßar atualiza√ß√£o
      _lastStaminaPercent = -1;
      
      // Reseta vida
      playerHearts = MAX_HEARTS;
      
      // Reseta stamina
      playerStamina = MAX_STAMINA;
      staminaRegenTimer = 0;
      canSprint = true;
      updateStaminaHUD();

      // Limpa monstros
      monsters.forEach(m => m.mesh && scene.remove(m.mesh));
      monsters = [];
      
      // Limpa proj√©teis
      projectiles.forEach(p => p.destroy());
      projectiles = [];
      
      // Limpa part√≠culas
      particles.forEach(p => {
        scene.remove(p.mesh);
        p.mesh.geometry.dispose();
        p.mesh.material.dispose();
      });
      particles.length = 0;

      // Limpa lixeiras
      bins.forEach(b => scene.remove(b.mesh));
      bins = [];
      
      // Limpa carros (carros s√£o o pr√≥prio mesh)
      cars.forEach(car => {
        scene.remove(car);
        car.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(m => m.dispose());
            } else {
              child.material.dispose();
            }
          }
        });
      });
      cars = [];
      
      // Limpa nuvens
      clouds.forEach(c => {
        scene.remove(c);
        c.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(m => m.dispose());
            } else {
              child.material.dispose();
            }
          }
        });
      });
      clouds = [];

      // NAO recria cidade - ela ja existe e nao precisa ser recriada
      // Apenas recria elementos dinamicos
      createBins();
      spawnTraffic();
      createCloudSystem();
      spawnInitialMonsters();

      if (player && player.object) {
        player.object.position.set(0, 0, 4);
        player.velocity.set(0, 0, 0);
        player.yaw = 0;
        cameraYaw = 0; // RE4: Reset da c√¢mera tamb√©m
        cameraPitch = 0;
        player.object.rotation.set(0, 0, 0);
        player.baseY = 0;
        player.verticalVelocity = 0;
        player.isGrounded = true;
        player.isKnockedDown = false;
        player.recoverTimer = 0;
      }
      
      // Reseta cooldown de atropelamento
      carHitCooldown = 0;

      spawnInitialMonsters();
      updateHUD();
      renderHearts();

      victoryScreen.style.display = "none";
      hudEl.style.display = "flex";
      controlsHint.style.display = "block";
      document.getElementById('ammoHud').style.display = "flex";
      currentWeapon = "Metal";
      document.querySelectorAll('.ammo-item').forEach(function(item) {
        item.classList.remove('selected');
        if (item.dataset.type === "Metal") item.classList.add('selected');
      });
      showMessage(
        "Novo jogo",
        "Transforme os monstros em sacos com a cor certa (1-4) e recicle!",
        2600
      );
    }

    // ==========================
    // INPUT
    // ==========================

    window.addEventListener("keydown", (e) => {
      // MENU DE PAUSE - ESC
      if (e.code === "Escape" && gameStarted && !gameCompleted) {
        togglePause();
        return;
      }
      
      // Se pausado, n√£o processa outras teclas
      if (isPaused) return;
      
      if (!gameStarted && (e.code === KEY_CODES.ENTER || e.code === KEY_CODES.SPACE)) {
        startGame();
        return;
      }
      if (gameCompleted && e.code === KEY_CODES.ENTER) {
        resetGame();
        return;
      }
      keys[e.code] = true;
      if (!gameStarted || gameCompleted) return;

      // Troca de muni√ß√£o
      if (e.key === "1") switchWeapon("Metal");
      if (e.key === "2") switchWeapon("Vidro");
      if (e.key === "3") switchWeapon("Pl√°stico");
      if (e.key === "4") switchWeapon("Papel");

      if (e.code === KEY_CODES.E) {
        handleInteract();
      } else if (e.code === KEY_CODES.Q) {
        handleDrop();
      } else if (e.code === KEY_CODES.SPACE) {
        // Jump - n√£o pode pular se estiver ca√≠do
        if (player.isGrounded && !player.isKnockedDown) {
          player.verticalVelocity = 10;
          player.isGrounded = false;
        }
      }
    });

    window.addEventListener("keyup", (e) => {
      keys[e.code] = false;
    });

    window.addEventListener("mousedown", (e) => {
      if (!gameStarted || gameCompleted) {
        startGame();
        return;
      }
      if (e.button === 0) {
        handleShoot();
      }
      if (e.button === 2) {
        isAiming = true;
        aimStartTime = clock.getElapsedTime();
        sniperReady = false;
      }
      mouseDown = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });

    window.addEventListener("mouseup", (e) => {
      mouseDown = false;
      if (e.button === 2) {
        isAiming = false;
        sniperReady = false;
        aimStartTime = 0;
        // Esconde e reseta a barra de carregamento
        const sniperChargeContainer = document.getElementById('sniper-charge-container');
        const sniperChargeBar = document.getElementById('sniper-charge-bar');
        if (sniperChargeContainer) sniperChargeContainer.classList.remove('visible');
        if (sniperChargeBar) {
          sniperChargeBar.style.width = '0%';
          sniperChargeBar.classList.remove('full');
        }
      }
    });
    
    // Desabilitar menu de contexto (bot√£o direito)
    window.addEventListener("contextmenu", (e) => {
      e.preventDefault();
    });

    window.addEventListener("mousemove", (e) => {
      if (!gameStarted || gameCompleted) return;

      crosshair.style.left = "50%";
      crosshair.style.top = "50%";
      
      // RE4: Crosshair menor ao mirar
      if (isAiming) {
        crosshair.classList.add('aiming');
      } else {
        crosshair.classList.remove('aiming');
        crosshair.classList.remove('sniper-ready');
      }

      if (mouseNDC) {
        // Mira fixa no centro da tela (RE4 style)
        mouseNDC.x = 0;
        mouseNDC.y = 0;
      }

      // Se pausado, n√£o move a c√¢mera
      if (isPaused) return;

      // RE4 Style: Mouse SEMPRE controla a c√¢mera (sem precisar segurar bot√£o)
      const dx = e.movementX || 0;
      const dy = e.movementY || 0;

      if (player && (dx !== 0 || dy !== 0)) {
        // Sensibilidade base * configura√ß√£o do jogador
        const baseSensitivity = isAiming ? 0.0015 : 0.003;
        const sensitivity = baseSensitivity * mouseSensitivity;
        
        // Horizontal (yaw) - gira a c√¢mera E o personagem
        cameraYaw -= dx * sensitivity;
        player.yaw = cameraYaw;
        // Personagem fica de COSTAS para a c√¢mera (adiciona 180 graus)
        player.object.rotation.y = cameraYaw + Math.PI;

        // Vertical (pitch) - inclina a c√¢mera
        cameraPitch -= dy * sensitivity;
        const PITCH_MIN = -0.5;
        const PITCH_MAX = 0.4;
        cameraPitch = THREE.MathUtils.clamp(cameraPitch, PITCH_MIN, PITCH_MAX);
      }
    });

    window.addEventListener("resize", () => {
      if (!renderer || !camera) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    victoryBtn.addEventListener("click", () => {
      resetGame();
    });

    // ==========================
    // GAME MECHANICS
    // ==========================

    function startGame() {
      if (gameStarted) return;
      gameStarted = true;
      initAudio();
      startScreen.style.opacity = "0";
      setTimeout(() => {
        startScreen.style.display = "none";
      }, 450);
      hudEl.style.display = "flex";
      controlsHint.style.display = "block";
      document.getElementById('ammoHud').style.display = "flex";
      
      // RE4: Capturar o mouse (Pointer Lock)
      document.body.requestPointerLock();
      
      spawnInitialMonsters();
      showMessage(
        "Sua Miss√£o üåç",
        "Transforme os monstros em sacos com a cor certa (1-4) e recicle!\n\nüü° 1-Metal  üü¢ 2-Vidro  üî¥ 3-Pl√°stico  üîµ 4-Papel",
        6000
      );
    }
    
    // ========== MENU DE PAUSE ==========
    const pauseMenu = document.getElementById('pauseMenu');
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeValue = document.getElementById('volumeValue');
    const sensitivitySlider = document.getElementById('sensitivitySlider');
    const sensitivityValue = document.getElementById('sensitivityValue');
    
    function togglePause() {
      isPaused = !isPaused;
      
      if (isPaused) {
        // Pausar
        pauseMenu.classList.add('active');
        document.exitPointerLock();
      } else {
        // Continuar
        pauseMenu.classList.remove('active');
        document.body.requestPointerLock();
      }
    }
    
    // Evento do slider de volume
    volumeSlider.addEventListener('input', (e) => {
      const value = e.target.value;
      gameVolume = value / 100;
      volumeValue.textContent = value + '%';
      
      // Aplicar volume a todos os sons
      if (typeof audioCtx !== 'undefined' && audioCtx) {
        // Volume j√° √© aplicado nos gains dos sons
      }
    });
    
    // Evento do slider de sensibilidade
    sensitivitySlider.addEventListener('input', (e) => {
      const value = e.target.value;
      mouseSensitivity = value / 100;
      sensitivityValue.textContent = value + '%';
    });
    
    // RE4: Re-capturar mouse ao clicar (se perdeu o foco)
    document.addEventListener('click', () => {
      if (gameStarted && !gameCompleted && !isPaused && document.pointerLockElement !== document.body) {
        document.body.requestPointerLock();
      }
    });

    function handleInteract() {
      if (!gameStarted || gameCompleted || isPickingBag) return;
      if (currentHeldBag) return;

      const bag = findNearbyBag(1.4);
      if (bag) {
        isPickingBag = true;
        currentHeldBag = bag;

        if (bag.mesh && bag.mesh.parent === scene) {
          scene.remove(bag.mesh);
        }

        createHeldBagVisual(bag);
        startPickAnimationLeftHand();

        showMessage(
          "Saco coletado",
          "Voc√™ pegou o saco com a m√£o esquerda. Leve-o at√© a lixeira correta.",
          2000
        );
        updateHUD();

        setTimeout(() => {
          isPickingBag = false;
        }, BAG_PICK_DURATION * 1000);
      }
    }

    function handleDrop() {
      if (!gameStarted || gameCompleted || isPickingBag) return;
      if (!currentHeldBag) return;
      const bin = findNearbyBin(1.8);
      if (!bin) {
        // Cor neutra (Branco ou Amarelo) para avisos
        document.getElementById("messageTitle").style.color = "#ffa502";
        showMessage("Chegue mais perto", "Aproxime-se de uma lixeira colorida para descartar o saco.", 1800);
        return;
      }
      const correctMaterial = currentHeldBag.type;
      const isCorrect = bin.def.material === correctMaterial;
      const titleEl = document.getElementById("messageTitle");
      if (isCorrect) {
        correctCount++;
        currentScore += 10;
        spawnRainParticlesAboveBin(bin, bin.def.color, 16);
        playCorrectSound();
        const msgEdu = {
          "Papel": "Papel limpo vai na lixeira azul. Evite papel engordurado.",
          "Pl√°stico": "Pl√°sticos limpos v√£o na vermelha: garrafas, embalagens, sacolas.",
          "Vidro": "Vidros inteiros v√£o na verde. Proteja cacos e nunca misture com org√¢nicos.",
          "Metal": "Latas e metais recicl√°veis v√£o na amarela. Lave antes de descartar."
        }[correctMaterial] || "Boa! Voc√™ escolheu a lixeira correta.";
        // --- COR VERDE (POSITIVO) ---
        titleEl.style.color = "#2ecc71"; 
        showMessage("DESCARTE CORRETO! ‚úÖ", `${msgEdu} (+10 pontos)`, 2600);
        destroyHeldBagVisual();
        if (currentHeldBag.mesh && currentHeldBag.mesh.parent) {
          currentHeldBag.mesh.parent.remove(currentHeldBag.mesh);
        }
        monsters = monsters.filter(m => m !== currentHeldBag);
        currentHeldBag = null;
        updateHUD();
        if (correctCount >= TARGET_CORRECT && !gameCompleted) {
          setTimeout(showVictory, 900);
        }
      } else {
        currentScore = Math.max(0, currentScore - 5);
        playWrongSound();
        // --- COR VERMELHA (NEGATIVO) ---
        titleEl.style.color = "#ff4757";
        showMessage(
          "OPS! LIXEIRA ERRADA ‚ùå",
          `Essa lixeira n√£o √© para ${currentHeldBag.type}. O saco caiu de volta no ch√£o. (-5 pontos)`,
          2600
        );
        dropBagAtPlayer(currentHeldBag);
        destroyHeldBagVisual();
        currentHeldBag = null;
        updateHUD();
      }
    }

    function dropBagAtPlayer(monster) {
      if (!monster) return;

      if (!monster.mesh || !monster.mesh.userData.isBag) {
        monster.toBag();
      }

      if (monster.mesh.parent !== scene) {
        scene.add(monster.mesh);
      }

      monster.state = "bag";

      const offset = new THREE.Vector3(
        (Math.random() - 0.5) * 1.0,
        0,
        (Math.random() - 0.5) * 1.0
      );
      monster.mesh.position.copy(player.object.position).add(offset);
      monster.mesh.position.y = 0.0;
    }

    function switchWeapon(type) {
      if (currentWeapon === type) return;
      currentWeapon = type;
      
      if (player && player.object) {
        player.object.traverse(function(child) {
          if (child.name === "gun_body" && child.material) {
            child.material.color.setHex(WEAPON_DATA[type].color);
          }
        });
      }
      
      document.querySelectorAll('.ammo-item').forEach(function(item) {
        item.classList.remove('selected');
        if (item.dataset.type === type) item.classList.add('selected');
      });
      
      // Atualizar destaque dos monstros
      updateMonsterHighlights();
      
      playTone({ freq: 880, duration: 0.06, type: "sine" });
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üéØ SISTEMA DE DESTAQUE DE MONSTROS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function updateMonsterHighlights() {
      for (const monster of monsters) {
        if (!monster.mesh || monster.state !== "alive") continue;
        
        const outline = monster.mesh.userData.outline;
        if (!outline) continue;
        
        // Mostrar outline se o monstro for da mesma cor da arma atual
        if (monster.type === currentWeapon) {
          outline.visible = true;
        } else {
          outline.visible = false;
        }
      }
    }
    
    // Faz o outline pulsar para chamar mais aten√ß√£o
    function updateOutlinePulse(time) {
      for (const monster of monsters) {
        if (!monster.mesh || monster.state !== "alive") continue;
        
        const outline = monster.mesh.userData.outline;
        if (!outline || !outline.visible) continue;
        
        // Pulsa√ß√£o suave - varia a escala e opacidade
        const pulse = 0.5 + Math.sin(time * 5) * 0.5; // 0 a 1
        const scale = 1.0 + pulse * 0.15; // 1.0 a 1.15
        
        outline.scale.set(scale, scale * 0.9, scale);
        outline.material.opacity = 0.5 + pulse * 0.5; // 0.5 a 1.0
      }
    }

    function handleShoot() {
      if (!gameStarted || gameCompleted || isPickingBag) return;

      const now = clock.getElapsedTime();
      if (now - lastShotTime < SHOOT_COOLDOWN) return;
      lastShotTime = now;

      // Verifica se √© um tiro sniper (mirando + carregado)
      const isSniperShot = isAiming && sniperReady;
      
      // Som diferente para sniper
      if (isSniperShot) {
        playSniperSound();
        player.shootRecoil = 0.25; // Mais recuo
        showMessage("üéØ SNIPER!", "Tiro cr√≠tico!", 1000);
      } else {
        playShootSound();
        player.shootRecoil = 0.14;
      }
      
      player.shootPose = 1.0;
      shootPoseTimer = 0.30;

      const gun = player.object.userData.gun;
      if (!gun) return;

      const muzzleWorld = new THREE.Vector3();
      // Usa a ponta da arma (gun_muzzle) como origem do tiro
      const muzzle = gun.getObjectByName("gun_muzzle") || gun.getObjectByName("gun_barrel") || gun;
      muzzle.getWorldPosition(muzzleWorld);

      raycaster.setFromCamera(mouseNDC, camera);
      if (!raycaster.ray.intersectPlane(aimPlane, aimPoint)) {
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        aimPoint.copy(muzzleWorld).addScaledVector(forward, 50);
      }

      // Verifica hit em monstros via raycaster
      const hitCandidates = [];
      monsters.forEach(function(m) {
        if (m.state === "alive" && m.mesh) {
          m.mesh.traverse(function(child) {
            if (child.isMesh) {
              child.userData.monsterRef = m;
              hitCandidates.push(child);
            }
          });
        }
      });

      const hits = raycaster.intersectObjects(hitCandidates, false);
      if (hits.length > 0) {
        const monster = hits[0].object.userData.monsterRef;
        if (monster) {
          if (monster.type === currentWeapon) {
            // Sniper = instakill (999 de dano)
            const damage = isSniperShot ? 999 : 1;
            monster.applyDamage(damage);
            const particleCount = isSniperShot ? 25 : 12;
            const particleSpeed = isSniperShot ? 8.0 : 5.0;
            spawnBurstParticles(hits[0].point, monster.color, particleCount, 0.4, particleSpeed);
          } else {
            spawnBurstParticles(hits[0].point, 0x666666, 6, 0.2, 2.0);
            playWrongSound();
            showMessage("‚ùå Cor errada!", "Use " + monster.type + " (tecla " + WEAPON_DATA[monster.type].key + ")", 1500);
          }
        }
      }

      const dir = new THREE.Vector3().subVectors(aimPoint, muzzleWorld).normalize();
      
      // Velocidade do proj√©til (sniper = 2x mais r√°pido)
      const speed = isSniperShot ? PROJECTILE_SPEED * 2 : PROJECTILE_SPEED;
      const proj = new Projectile(muzzleWorld, dir, WEAPON_DATA[currentWeapon].color, speed, isSniperShot);
      projectiles.push(proj);
      
      // Reseta o sniper ap√≥s o tiro
      if (isSniperShot) {
        sniperReady = false;
        aimStartTime = clock.getElapsedTime();
        crosshair.classList.remove('sniper-ready');
        // Reseta a barra de carregamento
        const sniperChargeBar = document.getElementById('sniper-charge-bar');
        if (sniperChargeBar) {
          sniperChargeBar.style.width = '0%';
          sniperChargeBar.classList.remove('full');
        }
      }
    }

    function findNearbyBag(radius) {
      const p = player.object.position;
      let best = null;
      let bestDist = radius;
      for (const m of monsters) {
        if (m.state !== "bag" || !m.mesh) continue;
        if (m === currentHeldBag) continue;
        const d = m.mesh.position.distanceTo(p);
        if (d < bestDist) {
          bestDist = d;
          best = m;
        }
      }
      return best;
    }

    function findNearbyBin(radius) {
      const p = player.object.position;
      let best = null;
      let bestDist = radius;
      bins.forEach(b => {
        const d = b.mesh.position.distanceTo(p);
        if (d < bestDist) {
          bestDist = d;
          best = b;
        }
      });
      return best;
    }

    // ==========================
    // HELD BAG VISUAL & ANIM
    // ==========================

    function createHeldBagVisual(monster) {
      destroyHeldBagVisual();

      if (!monster.mesh || !monster.mesh.userData.isBag) {
        monster.toBag();
      }

      const socket = player?.rig?.bagSocketL;
      if (!socket) return;

      currentHeldBagMesh = monster.mesh;
      currentHeldBagMesh.rotation.set(0, 0, 0);
      currentHeldBagMesh.position.set(0, -0.15, 0); // Posiciona abaixo da m√£o
      // Escala menor para ficar proporcional na m√£o (0.5 = metade do tamanho)
      currentHeldBagMesh.scale.set(0.5, 0.5, 0.5);

      socket.add(currentHeldBagMesh);
      currentHeldBagCarryOffset = 0;
    }

    function destroyHeldBagVisual() {
      if (!currentHeldBagMesh) return;
      const parent = currentHeldBagMesh.parent;
      if (parent) {
        parent.remove(currentHeldBagMesh);
      }
      currentHeldBagMesh = null;
    }

    function startPickAnimationLeftHand() {
      const r = player?.rig;
      if (!r) return;

      const start = {
        torso_x: r.torso.rotation.x,
        torso_y: r.torso.rotation.y,
        sL_x: r.shoulderL.rotation.x,
        sL_z: r.shoulderL.rotation.z,
        eL_x: r.elbowL.rotation.x,
        wristL_x: r.wristL.rotation.x
      };

      const target = {
        torso_x: -0.25,
        torso_y: 0.18,
        sL_x: 0.6,
        sL_z: -0.3,
        eL_x: 0.9,
        wristL_x: 0.4
      };

      const dur = BAG_PICK_DURATION;
      const startTime = globalTime;

      function animatePick() {
        const t = (globalTime - startTime) / dur;
        if (t >= 1 || !isPickingBag) {
          return;
        }

        const ease = t < 0.5
          ? 2 * t * t
          : -1 + (4 - 2 * t) * t;

        r.torso.rotation.x = THREE.MathUtils.lerp(start.torso_x, target.torso_x, ease);
        r.torso.rotation.y = THREE.MathUtils.lerp(start.torso_y, target.torso_y, ease);
        r.shoulderL.rotation.x = THREE.MathUtils.lerp(start.sL_x, target.sL_x, ease);
        r.shoulderL.rotation.z = THREE.MathUtils.lerp(start.sL_z, target.sL_z, ease);
        r.elbowL.rotation.x = THREE.MathUtils.lerp(start.eL_x, target.eL_x, ease);
        r.wristL.rotation.x = THREE.MathUtils.lerp(start.wristL_x, target.wristL_x, ease);

        requestAnimationFrame(animatePick);
      }

      requestAnimationFrame(animatePick);
    }

    function updateHeldBag(delta) {
      if (!currentHeldBag || !currentHeldBagMesh || !player?.rig?.bagSocketL) return;

      currentHeldBagCarryOffset += delta * BAG_CARRY_BOB_FREQ;
      const bob = Math.sin(currentHeldBagCarryOffset) * BAG_CARRY_BOB_AMPL;

      const socket = player.rig.bagSocketL;
      if (currentHeldBagMesh.parent !== socket) {
        socket.add(currentHeldBagMesh);
        currentHeldBagMesh.position.set(0, -0.15, 0);
        currentHeldBagMesh.scale.set(0.5, 0.5, 0.5); // Mant√©m escala pequena
      }

      currentHeldBagMesh.position.y = -0.15 + bob;
      currentHeldBagMesh.rotation.z = Math.sin(currentHeldBagCarryOffset) * 0.18;
      currentHeldBagMesh.rotation.x = 0.18;
    }

    // ==========================
    // MOVEMENT, CAMERA, RIG
    // ==========================

function updatePlayer(delta) {
  // --- L√ìGICA DE QUEDA E RECUPERA√á√ÉO ---
  if (player.isKnockedDown) {
      player.recoverTimer -= delta;
      
      // Gravidade continua agindo
      player.baseY = Math.max(0, player.baseY + player.verticalVelocity * delta);
      player.verticalVelocity -= 30 * delta;
      const gh = getGroundHeight(player.object.position.x, player.object.position.z);
      if (player.baseY <= gh) { player.baseY = gh; player.verticalVelocity = 0; }
      player.object.position.y = player.baseY;
      
      // Aplica arrasto no ch√£o (deslizar)
      player.velocity.multiplyScalar(0.90);
      player.object.position.addScaledVector(player.velocity, delta);

      // Levantar quando o tempo acabar
      if (player.recoverTimer <= 0) {
          player.isKnockedDown = false;
          // Anima√ß√£o de levantar (Reset suave ou direto)
          player.object.rotation.x = 0; 
          player.object.rotation.z = 0;
          player.object.position.y = player.baseY;
      }
      return; // IMPEDE MOVIMENTO WASD ENQUANTO EST√Å CA√çDO
  }

  // --- MOVIMENTO NORMAL (WASD) ---
  const forward = (keys[KEY_CODES.W] ? 1 : 0) - (keys[KEY_CODES.S] ? 1 : 0);
  const strafe  = (keys[KEY_CODES.D] ? 1 : 0) - (keys[KEY_CODES.A] ? 1 : 0);
  const isMoving = forward !== 0 || strafe !== 0;
  
  // Sistema de Stamina
  const wantsSprint = keys[KEY_CODES.SHIFT] && isMoving;
  let isSprinting = false;
  
  if (wantsSprint && canSprint && playerStamina > 0) {
    // Est√° correndo - gasta stamina
    isSprinting = true;
    playerIsSprinting = true; // Atualiza estado global para anima√ß√£o
    playerStamina -= STAMINA_DRAIN_RATE * delta;
    staminaRegenTimer = STAMINA_REGEN_DELAY;
    
    if (playerStamina <= 0) {
      playerStamina = 0;
      canSprint = false; // Precisa esperar recuperar um pouco
    }
  } else {
    // N√£o est√° correndo - recupera stamina
    playerIsSprinting = false; // Atualiza estado global para anima√ß√£o
    if (staminaRegenTimer > 0) {
      staminaRegenTimer -= delta;
    } else {
      playerStamina += STAMINA_REGEN_RATE * delta;
      if (playerStamina >= MAX_STAMINA) {
        playerStamina = MAX_STAMINA;
      }
      // Pode correr novamente quando tiver pelo menos 20% de stamina
      if (playerStamina >= MAX_STAMINA * 0.2) {
        canSprint = true;
      }
    }
  }
  
  // Atualiza HUD de stamina
  updateStaminaHUD();
  
  // Velocidade: normal, correndo, ou mirando (mais lento)
  let currentSpeed = player.speed;
  if (isAiming) {
    currentSpeed = player.speed * 0.5; // Mais lento ao mirar
  } else if (isSprinting) {
    currentSpeed = player.speed * 1.4;
  }

  // RE4 STYLE: Movimento relativo √† dire√ß√£o da c√¢mera
  if (forward === 0 && strafe === 0) {
    player.velocity.x *= 0.85;
    player.velocity.z *= 0.85;
  } else {
    // Usa cameraYaw para calcular dire√ß√£o de movimento
    const ang = cameraYaw;
    const dirX = (forward * -Math.sin(ang)) + (strafe * Math.cos(ang));
    const dirZ = (forward * -Math.cos(ang)) - (strafe * Math.sin(ang));
    const len = Math.hypot(dirX, dirZ) || 1;
    
    player.velocity.x = (dirX / len) * currentSpeed;
    player.velocity.z = (dirZ / len) * currentSpeed;

    // Personagem sempre olha para onde a c√¢mera aponta (RE4 style)
    // N√£o gira ao andar, s√≥ com o mouse
  }

  // Gravidade e Ch√£o
  player.baseY = Math.max(0, player.baseY + player.verticalVelocity * delta);
  player.verticalVelocity -= 30 * delta;

  const groundHeight = getGroundHeight(player.object.position.x, player.object.position.z);
  if (player.baseY <= groundHeight) {
    player.baseY = groundHeight;
    player.verticalVelocity = 0;
    player.isGrounded = true;
  } else {
    player.isGrounded = false;
  }

  // Bobbing
  const moving = (forward !== 0 || strafe !== 0);
  const idleOffset = (!moving && player.isGrounded) ? Math.sin(rigTime * 2.0) * 0.02 : 0;
  player.object.position.y = player.baseY + idleOffset;

  // Aplica Posi√ß√£o
  const disp = player.velocity.clone().multiplyScalar(delta);
  player.object.position.add(disp);

  // Colis√£o Cen√°rio
  for(let i=0; i<3; i++) resolveCapsuleVsColliders(player.object.position, 0.45);
  applySelfCollision();

  // Limites
  const halfSpan = GRID_RADIUS * BLOCK_SIZE + ROAD_W + SIDEWALK_W;
  player.object.position.x = THREE.MathUtils.clamp(player.object.position.x, -halfSpan, halfSpan);
  player.object.position.z = THREE.MathUtils.clamp(player.object.position.z, -halfSpan, halfSpan);
}

    function applySelfCollision() {
      const pPos = player.object.position;
      const rPlayer = SELF_COLLISION_RADIUS_PLAYER;

      for (const m of monsters) {
        if (!m.mesh || m === currentHeldBag) continue;

        // Usa vetor tempor√°rio em vez de criar novo
        const mPos = m.mesh.getWorldPosition(_tempVec3_1);
        const rOther = m.collisionRadius || SELF_COLLISION_RADIUS_BAG;
        const minDist = rPlayer + rOther;

        const dx = pPos.x - mPos.x;
        const dz = pPos.z - mPos.z;
        const distSq = dx * dx + dz * dz;

        if (distSq > minDist * minDist || distSq === 0) continue;

        const dist = Math.sqrt(distSq) || 1e-5;
        const overlap = minDist - dist;
        const nx = dx / dist;
        const nz = dz / dist;

        pPos.x += nx * overlap * SELF_COLLISION_STRENGTH;
        pPos.z += nz * overlap * SELF_COLLISION_STRENGTH;
      }
    }

    function updateCamera(delta) {
      // ========== RESIDENT EVIL 4 SHOULDER CAM ==========
      // C√¢mera ATR√ÅS do personagem, sobre o ombro direito
      // Mira fixa no centro da tela
      
      const recoilOffset = player.shootRecoil > 0 ? 0.08 * (player.shootRecoil / 0.14) : 0;
      
      // Par√¢metros da c√¢mera
      const shoulderOffsetX = isAiming ? 0.5 : 0.7;   // Offset lateral (ombro direito)
      const shoulderOffsetY = isAiming ? 1.4 : 1.6;   // Altura da c√¢mera
      const distanceBehind = isAiming ? 2.5 : 3.5;    // Dist√¢ncia ATR√ÅS do personagem
      
      const playerPos = player.object.position.clone();
      
      // Dire√ß√£o que o personagem est√° olhando (baseado no cameraYaw)
      // CORRIGIDO: Invertido para c√¢mera ficar ATR√ÅS
      const forwardDir = new THREE.Vector3(
        Math.sin(cameraYaw),
        0,
        Math.cos(cameraYaw)
      );
      
      // Dire√ß√£o lateral (para o ombro direito)
      const rightDir = new THREE.Vector3(
        Math.cos(cameraYaw),
        0,
        -Math.sin(cameraYaw)
      );
      
      // Posi√ß√£o da c√¢mera: ATR√ÅS do personagem + offset do ombro
      const cameraTarget = new THREE.Vector3();
      cameraTarget.copy(playerPos);
      cameraTarget.addScaledVector(forwardDir, distanceBehind);   // ATR√ÅS do personagem
      cameraTarget.addScaledVector(rightDir, shoulderOffsetX);     // Ombro direito
      cameraTarget.y = playerPos.y + shoulderOffsetY + cameraPitch * 1.0 - recoilOffset;
      
      // Interpola√ß√£o suave
      const lerpSpeed = isAiming ? 0.12 : 0.08;
      cameraPivot.position.lerp(cameraTarget, lerpSpeed);
      camera.position.copy(cameraPivot.position);
      
      // C√¢mera olha para FRENTE do personagem (na dire√ß√£o que ele olha)
      const lookDistance = 20;
      const lookTarget = new THREE.Vector3();
      lookTarget.copy(playerPos);
      lookTarget.addScaledVector(forwardDir, -lookDistance);  // √Ä FRENTE do personagem
      lookTarget.y = playerPos.y + 1.0 + cameraPitch * 8;
      
      camera.lookAt(lookTarget);
      
      // FOV din√¢mico
      const targetFov = isAiming ? 50 : 65;
      camera.fov += (targetFov - camera.fov) * 0.1;
      camera.updateProjectionMatrix();
    }

    function updateGun(delta) {
      const gun = player?.object?.userData?.gun;
      if (!gun || !gunBaseLocalPos || !camera) return;

      // 1) Recompute aimPoint every frame from mouse + camera
      if (raycaster && mouseNDC && aimPlane && aimPoint) {
        raycaster.setFromCamera(mouseNDC, camera);

        if (!raycaster.ray.intersectPlane(aimPlane, aimPoint)) {
          // Fallback: straight ahead from the camera
          const forward = new THREE.Vector3();
          camera.getWorldDirection(forward);

          const gunWorld = new THREE.Vector3();
          gun.getWorldPosition(gunWorld);

          aimPoint.copy(gunWorld).addScaledVector(forward, 10);
        }
      }

      // 2) Rotate the gun so that its local +Z axis (barrel direction) points to aimPoint
      const parent = gun.parent;
      if (parent && aimPoint) {
        parent.updateWorldMatrix(true, false);

        const gunWorld = new THREE.Vector3();
        gun.getWorldPosition(gunWorld);

        // Target in parent's local space
        const parentInv = new THREE.Matrix4().copy(parent.matrixWorld).invert();
        const targetLocal = aimPoint.clone().applyMatrix4(parentInv);

        const fromLocal = gun.position.clone();
        const dirLocal = targetLocal.sub(fromLocal).normalize();

        // Local +Z axis (barrel/muzzle direction) -> dirLocal
        // A arma est√° modelada com +Z sendo "para frente" (cano em Z positivo)
        const quatTarget = new THREE.Quaternion();
        quatTarget.setFromUnitVectors(new THREE.Vector3(0, 0, 1), dirLocal);

        // Smoothly blend towards the target rotation
        gun.quaternion.slerp(quatTarget, 0.35);
      }

      // 3) Recoil kick (keeps working as before)
      if (player.shootRecoil > 0) {
        player.shootRecoil = Math.max(0, player.shootRecoil - delta * 0.8);
      }

      const kickT = player.shootRecoil / 0.14;
      const targetLocalPos = new THREE.Vector3(
        gunBaseLocalPos.x,
        gunBaseLocalPos.y - 0.02 * kickT,
        gunBaseLocalPos.z - 0.03 * kickT  // Recuo para tr√°s em Z
      );
      gun.position.lerp(targetLocalPos, 0.6);
    }

    function sampleGroundY(x, z) {
      if (!groundRay || groundTargets.length === 0) return 0;
      const origin = new THREE.Vector3(x, 5, z);
      const down   = new THREE.Vector3(0, -1, 0);
      groundRay.set(origin, down);
      const hits = groundRay.intersectObjects(groundTargets, false);
      if (hits && hits.length) return hits[0].point.y;
      return 0;
    }

    function keepOutOfTorso(worldPos, torsoWorldCenterY) {
      const torsoCenter = new THREE.Vector3();
      player.rig.torso.getWorldPosition(torsoCenter);
      torsoCenter.y = torsoWorldCenterY;

      const v = new THREE.Vector3().subVectors(worldPos, torsoCenter);
      v.y = 0;
      const dist = v.length();
      const minDist = TORSO_RADIUS + ARM_CLEARANCE;
      if (dist >= minDist || dist < 1e-5) return worldPos.clone();

      const push = v.normalize().multiplyScalar(minDist);
      const corrected = torsoCenter.clone().add(push);
      corrected.y = worldPos.y;
      return corrected;
    }

    function updateBackpack(delta, moving, walkAmp, sw, cw) {
      const r = player.rig;
      backpackBouncePhase += delta * (moving ? 10 : 4);

      const baseY = 0.20;
      const vertical = moving
        ? Math.sin(backpackBouncePhase) * 0.015 * walkAmp
        : Math.sin(backpackBouncePhase) * 0.005;
      const swayX = moving ? sw * 0.015 * walkAmp : 0;
      const swayZ = moving ? cw * 0.015 * walkAmp : 0;

      r.backpackRoot.position.set(swayX, baseY + vertical, -0.12 + swayZ);

      const tiltX = moving ? -0.08 * walkAmp : -0.01;
      const tiltY = moving ? sw * 0.06 * walkAmp : 0;
      r.backpackRoot.rotation.x = tiltX;
      r.backpackRoot.rotation.y = tiltY;

      r.flap.rotation.x = 0.04 + Math.sin(backpackBouncePhase * 2.2) * 0.04 * walkAmp;
    }

    function applyTwoHandShootPose(rig, alpha) {
      if (alpha <= 0) return;

      // Smooth easing for nicer animation
      const t = alpha * alpha * (2 - alpha);

      // Right arm: main hand on the grip
      rig.shoulderR.rotation.x = THREE.MathUtils.lerp(
        rig.shoulderR.rotation.x,
        -0.55,
        t
      );
      rig.shoulderR.rotation.z = THREE.MathUtils.lerp(
        rig.shoulderR.rotation.z,
        0.25,
        t
      );
      rig.elbowR.rotation.x = THREE.MathUtils.lerp(
        rig.elbowR.rotation.x,
        0.9,
        t
      );
      rig.wristR.rotation.x = THREE.MathUtils.lerp(
        rig.wristR.rotation.x,
        -0.6,
        t
      );

      // Left arm: support hand under the barrel
      rig.shoulderL.rotation.x = THREE.MathUtils.lerp(
        rig.shoulderL.rotation.x,
        -0.35,
        t
      );
      rig.shoulderL.rotation.z = THREE.MathUtils.lerp(
        rig.shoulderL.rotation.z,
        -0.65,
        t
      );
      rig.elbowL.rotation.x = THREE.MathUtils.lerp(
        rig.elbowL.rotation.x,
        1.0,
        t
      );
      rig.wristL.rotation.x = THREE.MathUtils.lerp(
        rig.wristL.rotation.x,
        -0.2,
        t
      );
    }

    function updatePlayerRig(delta) {
      if (!player?.rig) return;
      rigTime += delta;

      // decay shoot pose over time (about 0.15‚Äì0.2s)
      if (player.shootPose > 0) {
        player.shootPose = Math.max(0, player.shootPose - delta * 6.0);
      }

      // Update two-hand shooting pose timer
      if (shootPoseTimer > 0) {
        shootPoseTimer = Math.max(0, shootPoseTimer - delta);
      }
      const shootBlend = THREE.MathUtils.clamp(shootPoseTimer / 0.30, 0, 1);

      const r = player.rig;

      const speed2D = Math.hypot(player.velocity.x, player.velocity.z);
      const moving = speed2D > 0.12;
      
      // ================================================================
      // SISTEMA DE ANIMA√á√ÉO AVAN√áADO - ANDAR vs CORRER
      // ================================================================
      const isRunning = playerIsSprinting && moving;
      
      // Frequ√™ncia base dos ciclos
      const walkFreq = isRunning ? 12.0 : 5.8;  // Andar mais lento e natural
      
      // Amplitude base normalizada pela velocidade
      const baseAmp = THREE.MathUtils.clamp(speed2D / 6, 0, 1.0);
      const walkAmp = isRunning ? Math.min(baseAmp * 1.8, 1.5) : baseAmp;
      
      // ================================================================
      // CICLO DE CAMINHADA AVAN√áADO (baseado em anima√ß√£o realista)
      // Fases: Contact ‚Üí Recoil ‚Üí Passing ‚Üí High Point ‚Üí Contact
      // ================================================================
      
      // Ondas base para o ciclo
      const phase = rigTime * walkFreq;
      const sw = Math.sin(phase);           // Onda principal
      const cw = Math.cos(phase);           // Onda complementar
      const sw2 = Math.sin(phase * 2);      // Harm√¥nica dupla (para detalhes)
      const cw2 = Math.cos(phase * 2);      // Harm√¥nica dupla complementar
      const swHalf = Math.sin(phase * 0.5); // Onda lenta (para balan√ßos suaves)
      
      // ================================================================
      // WALKING ANIMATION - Sistema elaborado de caminhada natural
      // ================================================================
      
      if (!isRunning && moving) {
        // ========== QUADRIS (HIPS) - Centro de massa e balan√ßo ==========
        
        // Bounce vertical duplo por ciclo (cada passo tem um "dip")
        // O ponto mais baixo √© quando o peso transfere para a perna de apoio
        const verticalBounce = Math.abs(sw2) * 0.018 * walkAmp;
        const weightShift = sw * 0.008 * walkAmp; // Leve descida lateral
        r.hips.position.y = 0.81 + verticalBounce - Math.abs(sw) * 0.006 * walkAmp;
        
        // Balan√ßo lateral dos quadris (hip sway) - essencial para andar natural
        // O quadril sobe do lado da perna que est√° no ar
        const hipSwayAmount = 0.045 * walkAmp;
        r.hips.rotation.z = sw * hipSwayAmount;
        
        // Rota√ß√£o dos quadris no eixo Y (contra-rota√ß√£o com torso)
        const hipRotationY = sw * 0.12 * walkAmp;
        r.hips.rotation.y = hipRotationY;
        
        // Leve inclina√ß√£o para frente ao andar
        r.hips.rotation.x = -0.03 * walkAmp;
        
        // ========== TORSO - Contra-rota√ß√£o e balan√ßo ==========
        
        // Contra-rota√ß√£o do torso (oposta aos quadris) - princ√≠pio fundamental
        const torsoCounterRotation = -sw * 0.15 * walkAmp;
        r.torso.rotation.y = THREE.MathUtils.lerp(r.torso.rotation.y, torsoCounterRotation, 0.2);
        
        // Inclina√ß√£o lateral sutil do torso (oposta ao hip sway)
        r.torso.rotation.z = -sw * 0.025 * walkAmp;
        
        // Inclina√ß√£o para frente (leve ao andar)
        const forwardLean = -0.06 * walkAmp;
        r.torso.rotation.x = THREE.MathUtils.lerp(r.torso.rotation.x, forwardLean, 0.15);
        
        // Posi√ß√£o do torso acompanha o bounce
        r.torso.position.y = 0.10 + verticalBounce * 0.3;
        
        // ========== CABE√áA - Estabiliza√ß√£o natural ==========
        
        // A cabe√ßa tende a se manter est√°vel (compensa√ß√£o vestibular)
        // Mas tem um leve balan√ßo natural
        const headStabilization = 0.4; // Quanto a cabe√ßa compensa o movimento do corpo
        r.headPivot.rotation.y = -r.torso.rotation.y * headStabilization;
        r.headPivot.rotation.z = -r.torso.rotation.z * 0.3;
        
        // Leve bob vertical da cabe√ßa (mais suave que o corpo)
        const headBob = Math.sin(phase + 0.3) * 0.015 * walkAmp;
        r.headPivot.rotation.x = headBob - r.torso.rotation.x * 0.25;
        r.headPivot.position.y = 0.35 + verticalBounce * 0.2;
        
        // ========== PERNAS - Ciclo de caminhada detalhado ==========
        
        // --- PERNA ESQUERDA ---
        // Coxa: movimento principal de p√™ndulo com fases distintas
        const thighSwingL = sw * 0.38 * walkAmp;
        // Adiciona "snap" no contato (momento que o p√© toca o ch√£o)
        const contactSnapL = Math.max(0, -cw) * 0.08 * walkAmp;
        r.thighL.rotation.x = thighSwingL + contactSnapL;
        
        // Abdu√ß√£o/Adu√ß√£o sutil da coxa (movimento lateral)
        r.thighL.rotation.z = sw * 0.02 * walkAmp;
        
        // Joelho: dobra durante a fase de swing (perna no ar)
        // Timing espec√≠fico: dobra quando a perna vai para frente
        const kneePhaseL = Math.max(0, -cw);
        const kneeFlexL = kneePhaseL * 0.55 * walkAmp;
        // Adiciona flex√£o extra no "passing" (perna passando embaixo do corpo)
        const passingFlexL = Math.max(0, Math.sin(phase - Math.PI * 0.3)) * 0.15 * walkAmp;
        r.kneeL.rotation.x = kneeFlexL + passingFlexL + 0.05;
        
        // Tornozelo: movimento complexo atrav√©s do ciclo
        // Dorsiflex√£o durante swing (p√© levanta), plantarflex√£o no push-off
        const ankleSwingL = sw * 0.12 * walkAmp;
        const anklePushL = Math.max(0, cw) * 0.1 * walkAmp; // Push-off
        r.ankleL.rotation.x = -0.05 + ankleSwingL - anklePushL;
        
        // P√©: rota√ß√£o sutil para simular heel-strike e toe-off
        const footRollL = -sw * 0.08 * walkAmp;
        r.footL.rotation.x = footRollL;
        // Rota√ß√£o lateral do p√© (supina√ß√£o/prona√ß√£o sutil)
        r.footL.rotation.z = cw * 0.03 * walkAmp;
        
        // --- PERNA DIREITA (fase oposta) ---
        const thighSwingR = -sw * 0.38 * walkAmp;
        const contactSnapR = Math.max(0, cw) * 0.08 * walkAmp;
        r.thighR.rotation.x = thighSwingR + contactSnapR;
        r.thighR.rotation.z = -sw * 0.02 * walkAmp;
        
        const kneePhaseR = Math.max(0, cw);
        const kneeFlexR = kneePhaseR * 0.55 * walkAmp;
        const passingFlexR = Math.max(0, Math.sin(phase + Math.PI * 0.7)) * 0.15 * walkAmp;
        r.kneeR.rotation.x = kneeFlexR + passingFlexR + 0.05;
        
        const ankleSwingR = -sw * 0.12 * walkAmp;
        const anklePushR = Math.max(0, -cw) * 0.1 * walkAmp;
        r.ankleR.rotation.x = -0.05 + ankleSwingR - anklePushR;
        
        const footRollR = sw * 0.08 * walkAmp;
        r.footR.rotation.x = footRollR;
        r.footR.rotation.z = -cw * 0.03 * walkAmp;
        
        // ========== BRA√áOS - Balan√ßo natural oposto √†s pernas ==========
        
        const gunHoldAngle = -0.25;
        
        if (!currentHeldBag && !isPickingBag) {
          // Bra√ßo direito (com arma) - movimento mais contido
          const armSwingR = 0.22 * walkAmp;
          r.shoulderR.rotation.x = -0.1 + (-sw * armSwingR);
          r.shoulderR.rotation.z = cw * 0.04 * walkAmp; // Leve rota√ß√£o lateral
          
          // Cotovelo dobra mais quando o bra√ßo vai para tr√°s
          const elbowFlexR = 0.35 + Math.max(0, cw) * 0.18 * walkAmp;
          r.elbowR.rotation.x = elbowFlexR;
          
          // Pulso com movimento natural
          r.wristR.rotation.x = gunHoldAngle + sw * 0.05 * walkAmp;
          r.wristR.rotation.z = cw * 0.03 * walkAmp;
          
          // Bra√ßo esquerdo (livre) - mais expressivo
          const armSwingL = 0.40 * walkAmp;
          r.shoulderL.rotation.x = sw * armSwingL;
          r.shoulderL.rotation.z = -cw * 0.06 * walkAmp;
          
          // Cotovelo com flex√£o din√¢mica
          const elbowFlexL = 0.25 + Math.max(0, -cw) * 0.30 * walkAmp;
          r.elbowL.rotation.x = elbowFlexL;
          
          // Pulso relaxado
          r.wristL.rotation.x = -0.1 + sw * 0.08 * walkAmp;
          r.wristL.rotation.z = sw * 0.04 * walkAmp;
        } else if (currentHeldBag && !isPickingBag) {
          // Segurando objeto - bra√ßo esquerdo fixo
          r.shoulderL.rotation.x = -0.2;
          r.shoulderL.rotation.z = -0.12;
          r.elbowL.rotation.x = 0.55;
          r.wristL.rotation.x = 0.25;
          
          // Bra√ßo direito ainda balan√ßa
          r.shoulderR.rotation.x = -0.1 + (-sw * 0.18 * walkAmp);
          r.elbowR.rotation.x = 0.35 + Math.max(0, cw) * 0.15 * walkAmp;
          r.wristR.rotation.x = gunHoldAngle;
        }
        
      } else if (isRunning && moving) {
        // ================================================================
        // RUNNING ANIMATION - Corrida expressiva (c√≥digo original melhorado)
        // ================================================================
        
        const runMult = 1.6;
        
        // Bounce vertical mais pronunciado na corrida
        const bounceFreq = walkFreq;
        const bounceAmp = 0.06;
        const bounce = Math.abs(Math.sin(rigTime * bounceFreq)) * bounceAmp * walkAmp;
        r.hips.position.y = 0.81 + bounce;
        
        // Hip sway reduzido na corrida (mais vertical)
        r.hips.rotation.z = sw * 0.03 * walkAmp;
        r.hips.rotation.y = sw * 0.08 * walkAmp;
        
        // Torso inclinado para frente
        const twistAmount = 0.35;
        const targetTwist = sw * twistAmount * walkAmp;
        r.torso.rotation.y = THREE.MathUtils.lerp(r.torso.rotation.y, targetTwist, 0.25);
        const forwardLean = -0.25;
        r.torso.rotation.x = THREE.MathUtils.lerp(r.torso.rotation.x, forwardLean * walkAmp, 0.25);
        r.torso.position.y = 0.10;
        
        // Cabe√ßa est√°vel
        const headBobAmount = 0.04;
        r.headPivot.rotation.x = Math.sin(rigTime * walkFreq * 0.5) * headBobAmount - r.torso.rotation.x * 0.35;
        r.headPivot.rotation.y = -r.torso.rotation.y * 0.6;
        r.headPivot.position.y = 0.35;
        
        // Pernas com amplitude maior
        const thighSwing = 0.55;
        r.thighL.rotation.x = sw * thighSwing * walkAmp;
        r.thighR.rotation.x = -sw * thighSwing * walkAmp;
        r.thighL.rotation.z = sw * 0.03 * walkAmp;
        r.thighR.rotation.z = -sw * 0.03 * walkAmp;
        
        const kneeFlexion = 0.95;
        r.kneeL.rotation.x = Math.max(0, -cw) * kneeFlexion * walkAmp;
        r.kneeR.rotation.x = Math.max(0, cw) * kneeFlexion * walkAmp;
        
        const ankleKick = 0.18;
        const ankleBase = -0.10;
        r.ankleL.rotation.x = ankleBase * walkAmp + Math.max(0, cw) * ankleKick * walkAmp;
        r.ankleR.rotation.x = ankleBase * walkAmp + Math.max(0, -cw) * ankleKick * walkAmp;
        
        r.footL.rotation.x = -sw * 0.1 * walkAmp;
        r.footR.rotation.x = sw * 0.1 * walkAmp;
        r.footL.rotation.z = 0;
        r.footR.rotation.z = 0;
        
        // Bra√ßos expressivos na corrida
        const gunHoldAngle = -0.25;
        r.shoulderR.rotation.z = 0;
        
        if (!currentHeldBag && !isPickingBag) {
          const armSwingR = 0.45;
          r.shoulderR.rotation.x = -0.1 + (-sw * armSwingR * walkAmp);
          r.elbowR.rotation.x = 0.35 + Math.max(0, cw) * 0.25 * walkAmp * runMult;
          r.wristR.rotation.x = gunHoldAngle;
          
          const armSwingL = 0.75;
          const elbowBendL = 0.45;
          r.shoulderL.rotation.z = 0;
          r.shoulderL.rotation.x = sw * armSwingL * walkAmp;
          r.elbowL.rotation.x = 0.25 + Math.max(0, -cw) * elbowBendL * walkAmp * runMult;
          r.wristL.rotation.x = -0.15;
        } else if (currentHeldBag && !isPickingBag) {
          r.shoulderL.rotation.x = -0.2;
          r.shoulderL.rotation.z = -0.12;
          r.elbowL.rotation.x = 0.55;
          r.wristL.rotation.x = 0.25;
          
          r.shoulderR.rotation.x = -0.1 + (-sw * 0.3 * walkAmp);
          r.elbowR.rotation.x = 0.35 + Math.max(0, cw) * 0.2 * walkAmp;
          r.wristR.rotation.x = gunHoldAngle;
        }
        
      } else {
        // ================================================================
        // IDLE ANIMATION - Parado com respira√ß√£o natural
        // ================================================================
        
        if (player.isGrounded) {
          // Respira√ß√£o suave
          const breathCycle = rigTime * 1.2;
          const breath = Math.sin(breathCycle) * 0.010;
          const breathChest = Math.sin(breathCycle + 0.5) * 0.006;
          
          // Micro-movimentos de peso (weight shift sutil)
          const idleSway = Math.sin(rigTime * 0.4) * 0.003;
          
          r.hips.position.y = 0.81 + breath;
          r.hips.rotation.z = idleSway;
          r.hips.rotation.y = 0;
          r.hips.rotation.x = 0;
          
          r.torso.position.y = 0.10 + breathChest;
          r.torso.rotation.x = -0.02 + breath * 0.06;
          r.torso.rotation.y *= 0.92; // Smooth return
          r.torso.rotation.z = -idleSway * 0.5;
          
          // Cabe√ßa com micro-movimentos
          const headIdle = Math.sin(rigTime * 0.7 + 1.0) * 0.008;
          r.headPivot.position.y = 0.35 + breathChest * 0.5;
          r.headPivot.rotation.x = headIdle;
          r.headPivot.rotation.y = Math.sin(rigTime * 0.3) * 0.01;
          r.headPivot.rotation.z = 0;
          
        } else {
          r.hips.position.y = 0.81;
          r.hips.rotation.z = 0;
          r.torso.position.y = 0.10;
          r.headPivot.position.y = 0.35;
        }
        
        // Pose relaxada das pernas
        r.thighL.rotation.x = 0.02;
        r.thighR.rotation.x = 0.02;
        r.thighL.rotation.z = 0;
        r.thighR.rotation.z = 0;
        r.kneeL.rotation.x = 0.05;
        r.kneeR.rotation.x = 0.05;
        r.ankleL.rotation.x = 0.0;
        r.ankleR.rotation.x = 0.0;
        r.footL.rotation.x = 0;
        r.footR.rotation.x = 0;
        r.footL.rotation.z = 0;
        r.footR.rotation.z = 0;
        
        // Bra√ßos em pose idle
        const gunHoldAngle = -0.25;
        if (!currentHeldBag && !isPickingBag) {
          r.shoulderR.rotation.x = -0.1;
          r.shoulderR.rotation.z = 0;
          r.elbowR.rotation.x = 0.35;
          r.wristR.rotation.x = gunHoldAngle;
          r.wristR.rotation.z = 0;
          
          r.shoulderL.rotation.x = 0;
          r.shoulderL.rotation.z = 0;
          r.elbowL.rotation.x = 0.15;
          r.wristL.rotation.x = -0.1;
          r.wristL.rotation.z = 0;
        }
      }

      updateBackpack(delta, moving, walkAmp, sw, cw);

      blinkTimer += delta;
      if (blinkTimer >= nextBlinkIn) {
        const blinkPhase = (blinkTimer - nextBlinkIn);
        const BLINK_DUR = 0.10;
        const t = 1 - THREE.MathUtils.clamp(blinkPhase / BLINK_DUR, 0, 1);
        const s = THREE.MathUtils.lerp(0.12, 1.0, t);
        r.eyeL.scale.y = s;
        r.eyeR.scale.y = s;

        if (blinkPhase > BLINK_DUR) {
          r.eyeL.scale.y = 1; r.eyeR.scale.y = 1;
          blinkTimer = 0;
          nextBlinkIn = 1.8 + Math.random() * 2.5;
        }
      }

      if (aimPoint) {
        const headWorld = new THREE.Vector3();
        r.head.getWorldPosition(headWorld);
        const toAim = new THREE.Vector3().subVectors(aimPoint, headWorld).normalize();
        
        // Pupilas agora s√£o filhas do container do olho
        // Movimento limitado para ficar DENTRO do olho branco
        const lookX = THREE.MathUtils.clamp(toAim.x * 0.008, -0.008, 0.008);
        const lookY = THREE.MathUtils.clamp(toAim.y * 0.005, -0.005, 0.005);

        // Posi√ß√£o relativa ao centro do olho (0,0,0.005)
        r.pupilL.position.x = lookX;
        r.pupilL.position.y = lookY;
        r.pupilR.position.x = lookX;
        r.pupilR.position.y = lookY;
      }

      r.shoulderL.rotation.y = THREE.MathUtils.clamp(r.shoulderL.rotation.y, -0.3, 0.6);
      r.shoulderR.rotation.y = THREE.MathUtils.clamp(r.shoulderR.rotation.y, -0.6, 0.3);
      r.shoulderL.rotation.z = THREE.MathUtils.clamp(r.shoulderL.rotation.z, -0.2, 1.1);
      r.shoulderR.rotation.z = THREE.MathUtils.clamp(r.shoulderR.rotation.z, -1.1, 0.2);

      // Limites para coxas - evita rota√ß√µes extremas e desconex√£o
      r.thighL.rotation.x = THREE.MathUtils.clamp(r.thighL.rotation.x, -0.6, 0.6);
      r.thighR.rotation.x = THREE.MathUtils.clamp(r.thighR.rotation.x, -0.6, 0.6);
      
      // Limites para joelhos - s√≥ dobram para tr√°s
      r.kneeL.rotation.x = THREE.MathUtils.clamp(r.kneeL.rotation.x, 0.0, 1.3);
      r.kneeR.rotation.x = THREE.MathUtils.clamp(r.kneeR.rotation.x, 0.0, 1.3);
      
      // Limites para tornozelos
      r.ankleL.rotation.x = THREE.MathUtils.clamp(r.ankleL.rotation.x, -0.4, 0.4);
      r.ankleR.rotation.x = THREE.MathUtils.clamp(r.ankleR.rotation.x, -0.4, 0.4);

      r.footL.rotation.x = THREE.MathUtils.clamp(r.footL.rotation.x, -0.35, 0.25);
      r.footR.rotation.x = THREE.MathUtils.clamp(r.footR.rotation.x, -0.35, 0.25);

      {
        const torsoCenter = new THREE.Vector3();
        r.torso.getWorldPosition(torsoCenter);

        const parts = [
          { pivot: r.elbowL, isLeft: true },
          { pivot: r.elbowR, isLeft: false },
        ];

        for (const p of parts) {
          const elbowW = new THREE.Vector3();
          p.pivot.getWorldPosition(elbowW);
          const correctedW = keepOutOfTorso(elbowW, torsoCenter.y);
          const penetration = correctedW.distanceTo(elbowW) > 1e-5;
          if (penetration) {
            const sign = p.isLeft ? 1 : -1;
            if (p.isLeft) {
              r.shoulderL.rotation.z = THREE.MathUtils.clamp(r.shoulderL.rotation.z, -0.2, 1.0);
            } else {
              r.shoulderR.rotation.z = THREE.MathUtils.clamp(r.shoulderR.rotation.z, -1.0, 0.2);
            }
            if (p.isLeft) {
              r.elbowL.rotation.z = Math.max(r.elbowL.rotation.z, 0.05 * sign);
            } else {
              r.elbowR.rotation.z = Math.max(r.elbowR.rotation.z, 0.05 * sign);
            }
          }
        }

        const handLw = new THREE.Vector3(), handRw = new THREE.Vector3();
        r.handLPalm.getWorldPosition(handLw);
        r.handRPalm.getWorldPosition(handRw);
        const hLc = keepOutOfTorso(handLw, torsoCenter.y);
        const hRc = keepOutOfTorso(handRw, torsoCenter.y);
        if (hLc.distanceTo(handLw) > 1e-5) r.shoulderL.rotation.z += 0.03;
        if (hRc.distanceTo(handRw) > 1e-5) r.shoulderR.rotation.z -= 0.03;
      }

      {
        // FOOT PLANTING DESATIVADO - causava desconex√£o visual dos p√©s
        // Os p√©s agora seguem naturalmente a hierarquia da perna
        // A anima√ß√£o das pernas j√° posiciona os p√©s corretamente
        
        // Se precisar de ajuste fino no futuro, usar rota√ß√µes ao inv√©s de posi√ß√£o
      }

      // --- Shooting arm override (run at the very end so it wins over walk/idle) ---
      if (player.shootPose > 0) {
        const t = player.shootPose; // 0..1

        // raise right arm to fire
        const targetShoulderRx = -1.0;  // arm up/forward
        const targetElbowRx    = 0.25;
        const targetWristRx    = -0.05;

        r.shoulderR.rotation.x = THREE.MathUtils.lerp(r.shoulderR.rotation.x, targetShoulderRx, t);
        r.elbowR.rotation.x    = THREE.MathUtils.lerp(r.elbowR.rotation.x,    targetElbowRx,    t);
        r.wristR.rotation.x    = THREE.MathUtils.lerp(r.wristR.rotation.x,    targetWristRx,    t);

        // left arm moves a bit to support the gun (two-hand feel)
        r.shoulderL.rotation.x = THREE.MathUtils.lerp(r.shoulderL.rotation.x, -0.45, t);
        r.elbowL.rotation.x    = THREE.MathUtils.lerp(r.elbowL.rotation.x,     0.60, t);
      }

      // Blend in two-hand pose when shooting (hands go to the launcher)
      applyTwoHandShootPose(r, shootBlend);
    }

    // ==========================
    // MAIN LOOP
    // ==========================

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock ? clock.getDelta() : 0.016;
      
      // Se pausado, n√£o atualiza o jogo (mas ainda renderiza)
      if (isPaused) {
        if (renderer && camera && scene) {
          renderer.render(scene, camera);
        }
        return;
      }
      
      globalTime += delta;

      if (gameStarted && !gameCompleted && !isGameOver) {
        // Inicializa cache DOM se necess√°rio
        if (!_domCacheInitialized) initDOMCache();
        
        // Verifica se o sniper est√° carregado e atualiza barra de carregamento
        if (isAiming && aimStartTime > 0) {
          const now = clock.getElapsedTime();
          const aimDuration = now - aimStartTime;
          
          // Atualiza barra de carregamento
          if (_cachedSniperContainer && _cachedSniperBar) {
            _cachedSniperContainer.classList.add('visible');
            const chargePercent = Math.min((aimDuration / SNIPER_CHARGE_TIME) * 100, 100);
            _cachedSniperBar.style.width = chargePercent + '%';
            
            if (chargePercent >= 100) {
              _cachedSniperBar.classList.add('full');
            } else {
              _cachedSniperBar.classList.remove('full');
            }
          }
          
          if (aimDuration >= SNIPER_CHARGE_TIME && !sniperReady) {
            sniperReady = true;
            crosshair.classList.add('sniper-ready');
            // Som de sniper carregado
            playTone({ freq: 1200, duration: 0.15, type: "sine", volume: 0.5, decay: 0.05 });
          }
        } else {
          // Esconde a barra quando n√£o est√° mirando
          if (_cachedSniperContainer && _cachedSniperBar) {
            _cachedSniperContainer.classList.remove('visible');
            _cachedSniperBar.style.width = '0%';
            _cachedSniperBar.classList.remove('full');
          }
        }
        
        updatePlayer(delta);
        updateCamera(delta);
        updateGun(delta);
        updatePlayerRig(delta);
        updateHeldBag(delta);
        updateCars(delta);

        const playerPos = player.object.position;
        for (const m of monsters) {
          if (m.mesh) m.update(delta, playerPos);
        }
        
        // Pulsa√ß√£o do outline dos monstros destacados
        updateOutlinePulse(globalTime);

        spawnMoreMonsters(delta);
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const alive = projectiles[i].update(delta);
          if (!alive) projectiles.splice(i, 1);
        }

        updateParticles(delta);

        const t = globalTime;
        const binCount = bins.length;
        for (let i = 0; i < binCount; i++) {
          const b = bins[i];
          const scale = 1 + Math.sin(t * 2 + b.glowPhase) * 0.02;
          b.mesh.scale.set(scale, 1, scale);
        }
        
        // Movimento das Nuvens (dentro do jogo para performance)
        const cloudCount = clouds.length;
        for (let i = 0; i < cloudCount; i++) {
          const c = clouds[i];
          c.position.x += c.userData.speed * 0.06; 
          
          // Loop infinito
          if (c.position.x > 200) {
            c.position.x = -200;
            c.position.z = (Math.random() - 0.5) * 400;
            c.position.y = c.userData.isLow ? (18 + Math.random() * 10) : (45 + Math.random() * 35);
          }
        }
      }
      
      if (renderer && camera && scene) {
        renderer.render(scene, camera);
      }
    }

    function main() {
      initRenderer();
      initScene();
      animate();
    }

    main();
  </script>
</body>
</html>


